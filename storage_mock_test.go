package pgqueue

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/kasorse/pgqueue.storage -o ./storage_mock_test.go -n StorageMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/jmoiron/sqlx"
)

// StorageMock implements storage
type StorageMock struct {
	t minimock.Tester

	funcabortTask          func(ctx context.Context, id int64, reason string) (err error)
	inspectFuncabortTask   func(ctx context.Context, id int64, reason string)
	afterabortTaskCounter  uint64
	beforeabortTaskCounter uint64
	abortTaskMock          mStorageMockabortTask

	funcaddRetriesToFailedTasks          func(ctx context.Context, kind int16, retryCnt int64) (err error)
	inspectFuncaddRetriesToFailedTasks   func(ctx context.Context, kind int16, retryCnt int64)
	afteraddRetriesToFailedTasksCounter  uint64
	beforeaddRetriesToFailedTasksCounter uint64
	addRetriesToFailedTasksMock          mStorageMockaddRetriesToFailedTasks

	funcarchiveClosedTasks          func(ctx context.Context, kind int16, waitingHours uint16) (err error)
	inspectFuncarchiveClosedTasks   func(ctx context.Context, kind int16, waitingHours uint16)
	afterarchiveClosedTasksCounter  uint64
	beforearchiveClosedTasksCounter uint64
	archiveClosedTasksMock          mStorageMockarchiveClosedTasks

	funccancelTaskByKey          func(ctx context.Context, kind int16, key string, reason string) (err error)
	inspectFunccancelTaskByKey   func(ctx context.Context, kind int16, key string, reason string)
	aftercancelTaskByKeyCounter  uint64
	beforecancelTaskByKeyCounter uint64
	cancelTaskByKeyMock          mStorageMockcancelTaskByKey

	funccloseExpiredTasks          func(ctx context.Context, kind int16) (err error)
	inspectFunccloseExpiredTasks   func(ctx context.Context, kind int16)
	aftercloseExpiredTasksCounter  uint64
	beforecloseExpiredTasksCounter uint64
	closeExpiredTasksMock          mStorageMockcloseExpiredTasks

	funccompleteTask          func(ctx context.Context, id int64, delaySeconds uint32) (err error)
	inspectFunccompleteTask   func(ctx context.Context, id int64, delaySeconds uint32)
	aftercompleteTaskCounter  uint64
	beforecompleteTaskCounter uint64
	completeTaskMock          mStorageMockcompleteTask

	funccreateTask          func(ctx context.Context, kind int16, maxAttempts uint16, payload []byte, ttlSeconds uint32, key string, delay time.Duration, endlessly bool) (err error)
	inspectFunccreateTask   func(ctx context.Context, kind int16, maxAttempts uint16, payload []byte, ttlSeconds uint32, key string, delay time.Duration, endlessly bool)
	aftercreateTaskCounter  uint64
	beforecreateTaskCounter uint64
	createTaskMock          mStorageMockcreateTask

	funccreateTaskTx          func(ctx context.Context, tx sqlx.Tx, kind int16, maxAttempts uint16, payload []byte, ttlSeconds uint32, key string, delay time.Duration, endlessly bool) (err error)
	inspectFunccreateTaskTx   func(ctx context.Context, tx sqlx.Tx, kind int16, maxAttempts uint16, payload []byte, ttlSeconds uint32, key string, delay time.Duration, endlessly bool)
	aftercreateTaskTxCounter  uint64
	beforecreateTaskTxCounter uint64
	createTaskTxMock          mStorageMockcreateTaskTx

	funcgetTasks          func(ctx context.Context, kind int16, workerCountLimitForInstance uint16, workerCountLimitForQueueKind uint16) (tpa1 []*Task, err error)
	inspectFuncgetTasks   func(ctx context.Context, kind int16, workerCountLimitForInstance uint16, workerCountLimitForQueueKind uint16)
	aftergetTasksCounter  uint64
	beforegetTasksCounter uint64
	getTasksMock          mStorageMockgetTasks

	funcrefuseTask          func(ctx context.Context, id int64, reason string, delaySeconds uint32) (err error)
	inspectFuncrefuseTask   func(ctx context.Context, id int64, reason string, delaySeconds uint32)
	afterrefuseTaskCounter  uint64
	beforerefuseTaskCounter uint64
	refuseTaskMock          mStorageMockrefuseTask

	funcrepairLostTasks          func(ctx context.Context, kind int16, lossSeconds uint32) (err error)
	inspectFuncrepairLostTasks   func(ctx context.Context, kind int16, lossSeconds uint32)
	afterrepairLostTasksCounter  uint64
	beforerepairLostTasksCounter uint64
	repairLostTasksMock          mStorageMockrepairLostTasks
}

// NewStorageMock returns a mock for storage
func NewStorageMock(t minimock.Tester) *StorageMock {
	m := &StorageMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.abortTaskMock = mStorageMockabortTask{mock: m}
	m.abortTaskMock.callArgs = []*StorageMockabortTaskParams{}

	m.addRetriesToFailedTasksMock = mStorageMockaddRetriesToFailedTasks{mock: m}
	m.addRetriesToFailedTasksMock.callArgs = []*StorageMockaddRetriesToFailedTasksParams{}

	m.archiveClosedTasksMock = mStorageMockarchiveClosedTasks{mock: m}
	m.archiveClosedTasksMock.callArgs = []*StorageMockarchiveClosedTasksParams{}

	m.cancelTaskByKeyMock = mStorageMockcancelTaskByKey{mock: m}
	m.cancelTaskByKeyMock.callArgs = []*StorageMockcancelTaskByKeyParams{}

	m.closeExpiredTasksMock = mStorageMockcloseExpiredTasks{mock: m}
	m.closeExpiredTasksMock.callArgs = []*StorageMockcloseExpiredTasksParams{}

	m.completeTaskMock = mStorageMockcompleteTask{mock: m}
	m.completeTaskMock.callArgs = []*StorageMockcompleteTaskParams{}

	m.createTaskMock = mStorageMockcreateTask{mock: m}
	m.createTaskMock.callArgs = []*StorageMockcreateTaskParams{}

	m.createTaskTxMock = mStorageMockcreateTaskTx{mock: m}
	m.createTaskTxMock.callArgs = []*StorageMockcreateTaskTxParams{}

	m.getTasksMock = mStorageMockgetTasks{mock: m}
	m.getTasksMock.callArgs = []*StorageMockgetTasksParams{}

	m.refuseTaskMock = mStorageMockrefuseTask{mock: m}
	m.refuseTaskMock.callArgs = []*StorageMockrefuseTaskParams{}

	m.repairLostTasksMock = mStorageMockrepairLostTasks{mock: m}
	m.repairLostTasksMock.callArgs = []*StorageMockrepairLostTasksParams{}

	return m
}

type mStorageMockabortTask struct {
	mock               *StorageMock
	defaultExpectation *StorageMockabortTaskExpectation
	expectations       []*StorageMockabortTaskExpectation

	callArgs []*StorageMockabortTaskParams
	mutex    sync.RWMutex
}

// StorageMockabortTaskExpectation specifies expectation struct of the storage.abortTask
type StorageMockabortTaskExpectation struct {
	mock    *StorageMock
	params  *StorageMockabortTaskParams
	results *StorageMockabortTaskResults
	Counter uint64
}

// StorageMockabortTaskParams contains parameters of the storage.abortTask
type StorageMockabortTaskParams struct {
	ctx    context.Context
	id     int64
	reason string
}

// StorageMockabortTaskResults contains results of the storage.abortTask
type StorageMockabortTaskResults struct {
	err error
}

// Expect sets up expected params for storage.abortTask
func (mmabortTask *mStorageMockabortTask) Expect(ctx context.Context, id int64, reason string) *mStorageMockabortTask {
	if mmabortTask.mock.funcabortTask != nil {
		mmabortTask.mock.t.Fatalf("StorageMock.abortTask mock is already set by Set")
	}

	if mmabortTask.defaultExpectation == nil {
		mmabortTask.defaultExpectation = &StorageMockabortTaskExpectation{}
	}

	mmabortTask.defaultExpectation.params = &StorageMockabortTaskParams{ctx, id, reason}
	for _, e := range mmabortTask.expectations {
		if minimock.Equal(e.params, mmabortTask.defaultExpectation.params) {
			mmabortTask.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmabortTask.defaultExpectation.params)
		}
	}

	return mmabortTask
}

// Inspect accepts an inspector function that has same arguments as the storage.abortTask
func (mmabortTask *mStorageMockabortTask) Inspect(f func(ctx context.Context, id int64, reason string)) *mStorageMockabortTask {
	if mmabortTask.mock.inspectFuncabortTask != nil {
		mmabortTask.mock.t.Fatalf("Inspect function is already set for StorageMock.abortTask")
	}

	mmabortTask.mock.inspectFuncabortTask = f

	return mmabortTask
}

// Return sets up results that will be returned by storage.abortTask
func (mmabortTask *mStorageMockabortTask) Return(err error) *StorageMock {
	if mmabortTask.mock.funcabortTask != nil {
		mmabortTask.mock.t.Fatalf("StorageMock.abortTask mock is already set by Set")
	}

	if mmabortTask.defaultExpectation == nil {
		mmabortTask.defaultExpectation = &StorageMockabortTaskExpectation{mock: mmabortTask.mock}
	}
	mmabortTask.defaultExpectation.results = &StorageMockabortTaskResults{err}
	return mmabortTask.mock
}

// Set uses given function f to mock the storage.abortTask method
func (mmabortTask *mStorageMockabortTask) Set(f func(ctx context.Context, id int64, reason string) (err error)) *StorageMock {
	if mmabortTask.defaultExpectation != nil {
		mmabortTask.mock.t.Fatalf("Default expectation is already set for the storage.abortTask method")
	}

	if len(mmabortTask.expectations) > 0 {
		mmabortTask.mock.t.Fatalf("Some expectations are already set for the storage.abortTask method")
	}

	mmabortTask.mock.funcabortTask = f
	return mmabortTask.mock
}

// When sets expectation for the storage.abortTask which will trigger the result defined by the following
// Then helper
func (mmabortTask *mStorageMockabortTask) When(ctx context.Context, id int64, reason string) *StorageMockabortTaskExpectation {
	if mmabortTask.mock.funcabortTask != nil {
		mmabortTask.mock.t.Fatalf("StorageMock.abortTask mock is already set by Set")
	}

	expectation := &StorageMockabortTaskExpectation{
		mock:   mmabortTask.mock,
		params: &StorageMockabortTaskParams{ctx, id, reason},
	}
	mmabortTask.expectations = append(mmabortTask.expectations, expectation)
	return expectation
}

// Then sets up storage.abortTask return parameters for the expectation previously defined by the When method
func (e *StorageMockabortTaskExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockabortTaskResults{err}
	return e.mock
}

// abortTask implements storage
func (mmabortTask *StorageMock) abortTask(ctx context.Context, id int64, reason string) (err error) {
	mm_atomic.AddUint64(&mmabortTask.beforeabortTaskCounter, 1)
	defer mm_atomic.AddUint64(&mmabortTask.afterabortTaskCounter, 1)

	if mmabortTask.inspectFuncabortTask != nil {
		mmabortTask.inspectFuncabortTask(ctx, id, reason)
	}

	mm_params := &StorageMockabortTaskParams{ctx, id, reason}

	// Record call args
	mmabortTask.abortTaskMock.mutex.Lock()
	mmabortTask.abortTaskMock.callArgs = append(mmabortTask.abortTaskMock.callArgs, mm_params)
	mmabortTask.abortTaskMock.mutex.Unlock()

	for _, e := range mmabortTask.abortTaskMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmabortTask.abortTaskMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmabortTask.abortTaskMock.defaultExpectation.Counter, 1)
		mm_want := mmabortTask.abortTaskMock.defaultExpectation.params
		mm_got := StorageMockabortTaskParams{ctx, id, reason}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmabortTask.t.Errorf("StorageMock.abortTask got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmabortTask.abortTaskMock.defaultExpectation.results
		if mm_results == nil {
			mmabortTask.t.Fatal("No results are set for the StorageMock.abortTask")
		}
		return (*mm_results).err
	}
	if mmabortTask.funcabortTask != nil {
		return mmabortTask.funcabortTask(ctx, id, reason)
	}
	mmabortTask.t.Fatalf("Unexpected call to StorageMock.abortTask. %v %v %v", ctx, id, reason)
	return
}

// abortTaskAfterCounter returns a count of finished StorageMock.abortTask invocations
func (mmabortTask *StorageMock) abortTaskAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmabortTask.afterabortTaskCounter)
}

// abortTaskBeforeCounter returns a count of StorageMock.abortTask invocations
func (mmabortTask *StorageMock) abortTaskBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmabortTask.beforeabortTaskCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.abortTask.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmabortTask *mStorageMockabortTask) Calls() []*StorageMockabortTaskParams {
	mmabortTask.mutex.RLock()

	argCopy := make([]*StorageMockabortTaskParams, len(mmabortTask.callArgs))
	copy(argCopy, mmabortTask.callArgs)

	mmabortTask.mutex.RUnlock()

	return argCopy
}

// MinimockabortTaskDone returns true if the count of the abortTask invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockabortTaskDone() bool {
	for _, e := range m.abortTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.abortTaskMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterabortTaskCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcabortTask != nil && mm_atomic.LoadUint64(&m.afterabortTaskCounter) < 1 {
		return false
	}
	return true
}

// MinimockabortTaskInspect logs each unmet expectation
func (m *StorageMock) MinimockabortTaskInspect() {
	for _, e := range m.abortTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.abortTask with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.abortTaskMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterabortTaskCounter) < 1 {
		if m.abortTaskMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.abortTask")
		} else {
			m.t.Errorf("Expected call to StorageMock.abortTask with params: %#v", *m.abortTaskMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcabortTask != nil && mm_atomic.LoadUint64(&m.afterabortTaskCounter) < 1 {
		m.t.Error("Expected call to StorageMock.abortTask")
	}
}

type mStorageMockaddRetriesToFailedTasks struct {
	mock               *StorageMock
	defaultExpectation *StorageMockaddRetriesToFailedTasksExpectation
	expectations       []*StorageMockaddRetriesToFailedTasksExpectation

	callArgs []*StorageMockaddRetriesToFailedTasksParams
	mutex    sync.RWMutex
}

// StorageMockaddRetriesToFailedTasksExpectation specifies expectation struct of the storage.addRetriesToFailedTasks
type StorageMockaddRetriesToFailedTasksExpectation struct {
	mock    *StorageMock
	params  *StorageMockaddRetriesToFailedTasksParams
	results *StorageMockaddRetriesToFailedTasksResults
	Counter uint64
}

// StorageMockaddRetriesToFailedTasksParams contains parameters of the storage.addRetriesToFailedTasks
type StorageMockaddRetriesToFailedTasksParams struct {
	ctx      context.Context
	kind     int16
	retryCnt int64
}

// StorageMockaddRetriesToFailedTasksResults contains results of the storage.addRetriesToFailedTasks
type StorageMockaddRetriesToFailedTasksResults struct {
	err error
}

// Expect sets up expected params for storage.addRetriesToFailedTasks
func (mmaddRetriesToFailedTasks *mStorageMockaddRetriesToFailedTasks) Expect(ctx context.Context, kind int16, retryCnt int64) *mStorageMockaddRetriesToFailedTasks {
	if mmaddRetriesToFailedTasks.mock.funcaddRetriesToFailedTasks != nil {
		mmaddRetriesToFailedTasks.mock.t.Fatalf("StorageMock.addRetriesToFailedTasks mock is already set by Set")
	}

	if mmaddRetriesToFailedTasks.defaultExpectation == nil {
		mmaddRetriesToFailedTasks.defaultExpectation = &StorageMockaddRetriesToFailedTasksExpectation{}
	}

	mmaddRetriesToFailedTasks.defaultExpectation.params = &StorageMockaddRetriesToFailedTasksParams{ctx, kind, retryCnt}
	for _, e := range mmaddRetriesToFailedTasks.expectations {
		if minimock.Equal(e.params, mmaddRetriesToFailedTasks.defaultExpectation.params) {
			mmaddRetriesToFailedTasks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmaddRetriesToFailedTasks.defaultExpectation.params)
		}
	}

	return mmaddRetriesToFailedTasks
}

// Inspect accepts an inspector function that has same arguments as the storage.addRetriesToFailedTasks
func (mmaddRetriesToFailedTasks *mStorageMockaddRetriesToFailedTasks) Inspect(f func(ctx context.Context, kind int16, retryCnt int64)) *mStorageMockaddRetriesToFailedTasks {
	if mmaddRetriesToFailedTasks.mock.inspectFuncaddRetriesToFailedTasks != nil {
		mmaddRetriesToFailedTasks.mock.t.Fatalf("Inspect function is already set for StorageMock.addRetriesToFailedTasks")
	}

	mmaddRetriesToFailedTasks.mock.inspectFuncaddRetriesToFailedTasks = f

	return mmaddRetriesToFailedTasks
}

// Return sets up results that will be returned by storage.addRetriesToFailedTasks
func (mmaddRetriesToFailedTasks *mStorageMockaddRetriesToFailedTasks) Return(err error) *StorageMock {
	if mmaddRetriesToFailedTasks.mock.funcaddRetriesToFailedTasks != nil {
		mmaddRetriesToFailedTasks.mock.t.Fatalf("StorageMock.addRetriesToFailedTasks mock is already set by Set")
	}

	if mmaddRetriesToFailedTasks.defaultExpectation == nil {
		mmaddRetriesToFailedTasks.defaultExpectation = &StorageMockaddRetriesToFailedTasksExpectation{mock: mmaddRetriesToFailedTasks.mock}
	}
	mmaddRetriesToFailedTasks.defaultExpectation.results = &StorageMockaddRetriesToFailedTasksResults{err}
	return mmaddRetriesToFailedTasks.mock
}

// Set uses given function f to mock the storage.addRetriesToFailedTasks method
func (mmaddRetriesToFailedTasks *mStorageMockaddRetriesToFailedTasks) Set(f func(ctx context.Context, kind int16, retryCnt int64) (err error)) *StorageMock {
	if mmaddRetriesToFailedTasks.defaultExpectation != nil {
		mmaddRetriesToFailedTasks.mock.t.Fatalf("Default expectation is already set for the storage.addRetriesToFailedTasks method")
	}

	if len(mmaddRetriesToFailedTasks.expectations) > 0 {
		mmaddRetriesToFailedTasks.mock.t.Fatalf("Some expectations are already set for the storage.addRetriesToFailedTasks method")
	}

	mmaddRetriesToFailedTasks.mock.funcaddRetriesToFailedTasks = f
	return mmaddRetriesToFailedTasks.mock
}

// When sets expectation for the storage.addRetriesToFailedTasks which will trigger the result defined by the following
// Then helper
func (mmaddRetriesToFailedTasks *mStorageMockaddRetriesToFailedTasks) When(ctx context.Context, kind int16, retryCnt int64) *StorageMockaddRetriesToFailedTasksExpectation {
	if mmaddRetriesToFailedTasks.mock.funcaddRetriesToFailedTasks != nil {
		mmaddRetriesToFailedTasks.mock.t.Fatalf("StorageMock.addRetriesToFailedTasks mock is already set by Set")
	}

	expectation := &StorageMockaddRetriesToFailedTasksExpectation{
		mock:   mmaddRetriesToFailedTasks.mock,
		params: &StorageMockaddRetriesToFailedTasksParams{ctx, kind, retryCnt},
	}
	mmaddRetriesToFailedTasks.expectations = append(mmaddRetriesToFailedTasks.expectations, expectation)
	return expectation
}

// Then sets up storage.addRetriesToFailedTasks return parameters for the expectation previously defined by the When method
func (e *StorageMockaddRetriesToFailedTasksExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockaddRetriesToFailedTasksResults{err}
	return e.mock
}

// addRetriesToFailedTasks implements storage
func (mmaddRetriesToFailedTasks *StorageMock) addRetriesToFailedTasks(ctx context.Context, kind int16, retryCnt int64) (err error) {
	mm_atomic.AddUint64(&mmaddRetriesToFailedTasks.beforeaddRetriesToFailedTasksCounter, 1)
	defer mm_atomic.AddUint64(&mmaddRetriesToFailedTasks.afteraddRetriesToFailedTasksCounter, 1)

	if mmaddRetriesToFailedTasks.inspectFuncaddRetriesToFailedTasks != nil {
		mmaddRetriesToFailedTasks.inspectFuncaddRetriesToFailedTasks(ctx, kind, retryCnt)
	}

	mm_params := &StorageMockaddRetriesToFailedTasksParams{ctx, kind, retryCnt}

	// Record call args
	mmaddRetriesToFailedTasks.addRetriesToFailedTasksMock.mutex.Lock()
	mmaddRetriesToFailedTasks.addRetriesToFailedTasksMock.callArgs = append(mmaddRetriesToFailedTasks.addRetriesToFailedTasksMock.callArgs, mm_params)
	mmaddRetriesToFailedTasks.addRetriesToFailedTasksMock.mutex.Unlock()

	for _, e := range mmaddRetriesToFailedTasks.addRetriesToFailedTasksMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmaddRetriesToFailedTasks.addRetriesToFailedTasksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmaddRetriesToFailedTasks.addRetriesToFailedTasksMock.defaultExpectation.Counter, 1)
		mm_want := mmaddRetriesToFailedTasks.addRetriesToFailedTasksMock.defaultExpectation.params
		mm_got := StorageMockaddRetriesToFailedTasksParams{ctx, kind, retryCnt}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmaddRetriesToFailedTasks.t.Errorf("StorageMock.addRetriesToFailedTasks got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmaddRetriesToFailedTasks.addRetriesToFailedTasksMock.defaultExpectation.results
		if mm_results == nil {
			mmaddRetriesToFailedTasks.t.Fatal("No results are set for the StorageMock.addRetriesToFailedTasks")
		}
		return (*mm_results).err
	}
	if mmaddRetriesToFailedTasks.funcaddRetriesToFailedTasks != nil {
		return mmaddRetriesToFailedTasks.funcaddRetriesToFailedTasks(ctx, kind, retryCnt)
	}
	mmaddRetriesToFailedTasks.t.Fatalf("Unexpected call to StorageMock.addRetriesToFailedTasks. %v %v %v", ctx, kind, retryCnt)
	return
}

// addRetriesToFailedTasksAfterCounter returns a count of finished StorageMock.addRetriesToFailedTasks invocations
func (mmaddRetriesToFailedTasks *StorageMock) addRetriesToFailedTasksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmaddRetriesToFailedTasks.afteraddRetriesToFailedTasksCounter)
}

// addRetriesToFailedTasksBeforeCounter returns a count of StorageMock.addRetriesToFailedTasks invocations
func (mmaddRetriesToFailedTasks *StorageMock) addRetriesToFailedTasksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmaddRetriesToFailedTasks.beforeaddRetriesToFailedTasksCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.addRetriesToFailedTasks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmaddRetriesToFailedTasks *mStorageMockaddRetriesToFailedTasks) Calls() []*StorageMockaddRetriesToFailedTasksParams {
	mmaddRetriesToFailedTasks.mutex.RLock()

	argCopy := make([]*StorageMockaddRetriesToFailedTasksParams, len(mmaddRetriesToFailedTasks.callArgs))
	copy(argCopy, mmaddRetriesToFailedTasks.callArgs)

	mmaddRetriesToFailedTasks.mutex.RUnlock()

	return argCopy
}

// MinimockaddRetriesToFailedTasksDone returns true if the count of the addRetriesToFailedTasks invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockaddRetriesToFailedTasksDone() bool {
	for _, e := range m.addRetriesToFailedTasksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.addRetriesToFailedTasksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afteraddRetriesToFailedTasksCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcaddRetriesToFailedTasks != nil && mm_atomic.LoadUint64(&m.afteraddRetriesToFailedTasksCounter) < 1 {
		return false
	}
	return true
}

// MinimockaddRetriesToFailedTasksInspect logs each unmet expectation
func (m *StorageMock) MinimockaddRetriesToFailedTasksInspect() {
	for _, e := range m.addRetriesToFailedTasksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.addRetriesToFailedTasks with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.addRetriesToFailedTasksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afteraddRetriesToFailedTasksCounter) < 1 {
		if m.addRetriesToFailedTasksMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.addRetriesToFailedTasks")
		} else {
			m.t.Errorf("Expected call to StorageMock.addRetriesToFailedTasks with params: %#v", *m.addRetriesToFailedTasksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcaddRetriesToFailedTasks != nil && mm_atomic.LoadUint64(&m.afteraddRetriesToFailedTasksCounter) < 1 {
		m.t.Error("Expected call to StorageMock.addRetriesToFailedTasks")
	}
}

type mStorageMockarchiveClosedTasks struct {
	mock               *StorageMock
	defaultExpectation *StorageMockarchiveClosedTasksExpectation
	expectations       []*StorageMockarchiveClosedTasksExpectation

	callArgs []*StorageMockarchiveClosedTasksParams
	mutex    sync.RWMutex
}

// StorageMockarchiveClosedTasksExpectation specifies expectation struct of the storage.archiveClosedTasks
type StorageMockarchiveClosedTasksExpectation struct {
	mock    *StorageMock
	params  *StorageMockarchiveClosedTasksParams
	results *StorageMockarchiveClosedTasksResults
	Counter uint64
}

// StorageMockarchiveClosedTasksParams contains parameters of the storage.archiveClosedTasks
type StorageMockarchiveClosedTasksParams struct {
	ctx          context.Context
	kind         int16
	waitingHours uint16
}

// StorageMockarchiveClosedTasksResults contains results of the storage.archiveClosedTasks
type StorageMockarchiveClosedTasksResults struct {
	err error
}

// Expect sets up expected params for storage.archiveClosedTasks
func (mmarchiveClosedTasks *mStorageMockarchiveClosedTasks) Expect(ctx context.Context, kind int16, waitingHours uint16) *mStorageMockarchiveClosedTasks {
	if mmarchiveClosedTasks.mock.funcarchiveClosedTasks != nil {
		mmarchiveClosedTasks.mock.t.Fatalf("StorageMock.archiveClosedTasks mock is already set by Set")
	}

	if mmarchiveClosedTasks.defaultExpectation == nil {
		mmarchiveClosedTasks.defaultExpectation = &StorageMockarchiveClosedTasksExpectation{}
	}

	mmarchiveClosedTasks.defaultExpectation.params = &StorageMockarchiveClosedTasksParams{ctx, kind, waitingHours}
	for _, e := range mmarchiveClosedTasks.expectations {
		if minimock.Equal(e.params, mmarchiveClosedTasks.defaultExpectation.params) {
			mmarchiveClosedTasks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmarchiveClosedTasks.defaultExpectation.params)
		}
	}

	return mmarchiveClosedTasks
}

// Inspect accepts an inspector function that has same arguments as the storage.archiveClosedTasks
func (mmarchiveClosedTasks *mStorageMockarchiveClosedTasks) Inspect(f func(ctx context.Context, kind int16, waitingHours uint16)) *mStorageMockarchiveClosedTasks {
	if mmarchiveClosedTasks.mock.inspectFuncarchiveClosedTasks != nil {
		mmarchiveClosedTasks.mock.t.Fatalf("Inspect function is already set for StorageMock.archiveClosedTasks")
	}

	mmarchiveClosedTasks.mock.inspectFuncarchiveClosedTasks = f

	return mmarchiveClosedTasks
}

// Return sets up results that will be returned by storage.archiveClosedTasks
func (mmarchiveClosedTasks *mStorageMockarchiveClosedTasks) Return(err error) *StorageMock {
	if mmarchiveClosedTasks.mock.funcarchiveClosedTasks != nil {
		mmarchiveClosedTasks.mock.t.Fatalf("StorageMock.archiveClosedTasks mock is already set by Set")
	}

	if mmarchiveClosedTasks.defaultExpectation == nil {
		mmarchiveClosedTasks.defaultExpectation = &StorageMockarchiveClosedTasksExpectation{mock: mmarchiveClosedTasks.mock}
	}
	mmarchiveClosedTasks.defaultExpectation.results = &StorageMockarchiveClosedTasksResults{err}
	return mmarchiveClosedTasks.mock
}

// Set uses given function f to mock the storage.archiveClosedTasks method
func (mmarchiveClosedTasks *mStorageMockarchiveClosedTasks) Set(f func(ctx context.Context, kind int16, waitingHours uint16) (err error)) *StorageMock {
	if mmarchiveClosedTasks.defaultExpectation != nil {
		mmarchiveClosedTasks.mock.t.Fatalf("Default expectation is already set for the storage.archiveClosedTasks method")
	}

	if len(mmarchiveClosedTasks.expectations) > 0 {
		mmarchiveClosedTasks.mock.t.Fatalf("Some expectations are already set for the storage.archiveClosedTasks method")
	}

	mmarchiveClosedTasks.mock.funcarchiveClosedTasks = f
	return mmarchiveClosedTasks.mock
}

// When sets expectation for the storage.archiveClosedTasks which will trigger the result defined by the following
// Then helper
func (mmarchiveClosedTasks *mStorageMockarchiveClosedTasks) When(ctx context.Context, kind int16, waitingHours uint16) *StorageMockarchiveClosedTasksExpectation {
	if mmarchiveClosedTasks.mock.funcarchiveClosedTasks != nil {
		mmarchiveClosedTasks.mock.t.Fatalf("StorageMock.archiveClosedTasks mock is already set by Set")
	}

	expectation := &StorageMockarchiveClosedTasksExpectation{
		mock:   mmarchiveClosedTasks.mock,
		params: &StorageMockarchiveClosedTasksParams{ctx, kind, waitingHours},
	}
	mmarchiveClosedTasks.expectations = append(mmarchiveClosedTasks.expectations, expectation)
	return expectation
}

// Then sets up storage.archiveClosedTasks return parameters for the expectation previously defined by the When method
func (e *StorageMockarchiveClosedTasksExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockarchiveClosedTasksResults{err}
	return e.mock
}

// archiveClosedTasks implements storage
func (mmarchiveClosedTasks *StorageMock) archiveClosedTasks(ctx context.Context, kind int16, waitingHours uint16) (err error) {
	mm_atomic.AddUint64(&mmarchiveClosedTasks.beforearchiveClosedTasksCounter, 1)
	defer mm_atomic.AddUint64(&mmarchiveClosedTasks.afterarchiveClosedTasksCounter, 1)

	if mmarchiveClosedTasks.inspectFuncarchiveClosedTasks != nil {
		mmarchiveClosedTasks.inspectFuncarchiveClosedTasks(ctx, kind, waitingHours)
	}

	mm_params := &StorageMockarchiveClosedTasksParams{ctx, kind, waitingHours}

	// Record call args
	mmarchiveClosedTasks.archiveClosedTasksMock.mutex.Lock()
	mmarchiveClosedTasks.archiveClosedTasksMock.callArgs = append(mmarchiveClosedTasks.archiveClosedTasksMock.callArgs, mm_params)
	mmarchiveClosedTasks.archiveClosedTasksMock.mutex.Unlock()

	for _, e := range mmarchiveClosedTasks.archiveClosedTasksMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmarchiveClosedTasks.archiveClosedTasksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmarchiveClosedTasks.archiveClosedTasksMock.defaultExpectation.Counter, 1)
		mm_want := mmarchiveClosedTasks.archiveClosedTasksMock.defaultExpectation.params
		mm_got := StorageMockarchiveClosedTasksParams{ctx, kind, waitingHours}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmarchiveClosedTasks.t.Errorf("StorageMock.archiveClosedTasks got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmarchiveClosedTasks.archiveClosedTasksMock.defaultExpectation.results
		if mm_results == nil {
			mmarchiveClosedTasks.t.Fatal("No results are set for the StorageMock.archiveClosedTasks")
		}
		return (*mm_results).err
	}
	if mmarchiveClosedTasks.funcarchiveClosedTasks != nil {
		return mmarchiveClosedTasks.funcarchiveClosedTasks(ctx, kind, waitingHours)
	}
	mmarchiveClosedTasks.t.Fatalf("Unexpected call to StorageMock.archiveClosedTasks. %v %v %v", ctx, kind, waitingHours)
	return
}

// archiveClosedTasksAfterCounter returns a count of finished StorageMock.archiveClosedTasks invocations
func (mmarchiveClosedTasks *StorageMock) archiveClosedTasksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmarchiveClosedTasks.afterarchiveClosedTasksCounter)
}

// archiveClosedTasksBeforeCounter returns a count of StorageMock.archiveClosedTasks invocations
func (mmarchiveClosedTasks *StorageMock) archiveClosedTasksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmarchiveClosedTasks.beforearchiveClosedTasksCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.archiveClosedTasks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmarchiveClosedTasks *mStorageMockarchiveClosedTasks) Calls() []*StorageMockarchiveClosedTasksParams {
	mmarchiveClosedTasks.mutex.RLock()

	argCopy := make([]*StorageMockarchiveClosedTasksParams, len(mmarchiveClosedTasks.callArgs))
	copy(argCopy, mmarchiveClosedTasks.callArgs)

	mmarchiveClosedTasks.mutex.RUnlock()

	return argCopy
}

// MinimockarchiveClosedTasksDone returns true if the count of the archiveClosedTasks invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockarchiveClosedTasksDone() bool {
	for _, e := range m.archiveClosedTasksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.archiveClosedTasksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterarchiveClosedTasksCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcarchiveClosedTasks != nil && mm_atomic.LoadUint64(&m.afterarchiveClosedTasksCounter) < 1 {
		return false
	}
	return true
}

// MinimockarchiveClosedTasksInspect logs each unmet expectation
func (m *StorageMock) MinimockarchiveClosedTasksInspect() {
	for _, e := range m.archiveClosedTasksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.archiveClosedTasks with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.archiveClosedTasksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterarchiveClosedTasksCounter) < 1 {
		if m.archiveClosedTasksMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.archiveClosedTasks")
		} else {
			m.t.Errorf("Expected call to StorageMock.archiveClosedTasks with params: %#v", *m.archiveClosedTasksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcarchiveClosedTasks != nil && mm_atomic.LoadUint64(&m.afterarchiveClosedTasksCounter) < 1 {
		m.t.Error("Expected call to StorageMock.archiveClosedTasks")
	}
}

type mStorageMockcancelTaskByKey struct {
	mock               *StorageMock
	defaultExpectation *StorageMockcancelTaskByKeyExpectation
	expectations       []*StorageMockcancelTaskByKeyExpectation

	callArgs []*StorageMockcancelTaskByKeyParams
	mutex    sync.RWMutex
}

// StorageMockcancelTaskByKeyExpectation specifies expectation struct of the storage.cancelTaskByKey
type StorageMockcancelTaskByKeyExpectation struct {
	mock    *StorageMock
	params  *StorageMockcancelTaskByKeyParams
	results *StorageMockcancelTaskByKeyResults
	Counter uint64
}

// StorageMockcancelTaskByKeyParams contains parameters of the storage.cancelTaskByKey
type StorageMockcancelTaskByKeyParams struct {
	ctx    context.Context
	kind   int16
	key    string
	reason string
}

// StorageMockcancelTaskByKeyResults contains results of the storage.cancelTaskByKey
type StorageMockcancelTaskByKeyResults struct {
	err error
}

// Expect sets up expected params for storage.cancelTaskByKey
func (mmcancelTaskByKey *mStorageMockcancelTaskByKey) Expect(ctx context.Context, kind int16, key string, reason string) *mStorageMockcancelTaskByKey {
	if mmcancelTaskByKey.mock.funccancelTaskByKey != nil {
		mmcancelTaskByKey.mock.t.Fatalf("StorageMock.cancelTaskByKey mock is already set by Set")
	}

	if mmcancelTaskByKey.defaultExpectation == nil {
		mmcancelTaskByKey.defaultExpectation = &StorageMockcancelTaskByKeyExpectation{}
	}

	mmcancelTaskByKey.defaultExpectation.params = &StorageMockcancelTaskByKeyParams{ctx, kind, key, reason}
	for _, e := range mmcancelTaskByKey.expectations {
		if minimock.Equal(e.params, mmcancelTaskByKey.defaultExpectation.params) {
			mmcancelTaskByKey.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmcancelTaskByKey.defaultExpectation.params)
		}
	}

	return mmcancelTaskByKey
}

// Inspect accepts an inspector function that has same arguments as the storage.cancelTaskByKey
func (mmcancelTaskByKey *mStorageMockcancelTaskByKey) Inspect(f func(ctx context.Context, kind int16, key string, reason string)) *mStorageMockcancelTaskByKey {
	if mmcancelTaskByKey.mock.inspectFunccancelTaskByKey != nil {
		mmcancelTaskByKey.mock.t.Fatalf("Inspect function is already set for StorageMock.cancelTaskByKey")
	}

	mmcancelTaskByKey.mock.inspectFunccancelTaskByKey = f

	return mmcancelTaskByKey
}

// Return sets up results that will be returned by storage.cancelTaskByKey
func (mmcancelTaskByKey *mStorageMockcancelTaskByKey) Return(err error) *StorageMock {
	if mmcancelTaskByKey.mock.funccancelTaskByKey != nil {
		mmcancelTaskByKey.mock.t.Fatalf("StorageMock.cancelTaskByKey mock is already set by Set")
	}

	if mmcancelTaskByKey.defaultExpectation == nil {
		mmcancelTaskByKey.defaultExpectation = &StorageMockcancelTaskByKeyExpectation{mock: mmcancelTaskByKey.mock}
	}
	mmcancelTaskByKey.defaultExpectation.results = &StorageMockcancelTaskByKeyResults{err}
	return mmcancelTaskByKey.mock
}

// Set uses given function f to mock the storage.cancelTaskByKey method
func (mmcancelTaskByKey *mStorageMockcancelTaskByKey) Set(f func(ctx context.Context, kind int16, key string, reason string) (err error)) *StorageMock {
	if mmcancelTaskByKey.defaultExpectation != nil {
		mmcancelTaskByKey.mock.t.Fatalf("Default expectation is already set for the storage.cancelTaskByKey method")
	}

	if len(mmcancelTaskByKey.expectations) > 0 {
		mmcancelTaskByKey.mock.t.Fatalf("Some expectations are already set for the storage.cancelTaskByKey method")
	}

	mmcancelTaskByKey.mock.funccancelTaskByKey = f
	return mmcancelTaskByKey.mock
}

// When sets expectation for the storage.cancelTaskByKey which will trigger the result defined by the following
// Then helper
func (mmcancelTaskByKey *mStorageMockcancelTaskByKey) When(ctx context.Context, kind int16, key string, reason string) *StorageMockcancelTaskByKeyExpectation {
	if mmcancelTaskByKey.mock.funccancelTaskByKey != nil {
		mmcancelTaskByKey.mock.t.Fatalf("StorageMock.cancelTaskByKey mock is already set by Set")
	}

	expectation := &StorageMockcancelTaskByKeyExpectation{
		mock:   mmcancelTaskByKey.mock,
		params: &StorageMockcancelTaskByKeyParams{ctx, kind, key, reason},
	}
	mmcancelTaskByKey.expectations = append(mmcancelTaskByKey.expectations, expectation)
	return expectation
}

// Then sets up storage.cancelTaskByKey return parameters for the expectation previously defined by the When method
func (e *StorageMockcancelTaskByKeyExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockcancelTaskByKeyResults{err}
	return e.mock
}

// cancelTaskByKey implements storage
func (mmcancelTaskByKey *StorageMock) cancelTaskByKey(ctx context.Context, kind int16, key string, reason string) (err error) {
	mm_atomic.AddUint64(&mmcancelTaskByKey.beforecancelTaskByKeyCounter, 1)
	defer mm_atomic.AddUint64(&mmcancelTaskByKey.aftercancelTaskByKeyCounter, 1)

	if mmcancelTaskByKey.inspectFunccancelTaskByKey != nil {
		mmcancelTaskByKey.inspectFunccancelTaskByKey(ctx, kind, key, reason)
	}

	mm_params := &StorageMockcancelTaskByKeyParams{ctx, kind, key, reason}

	// Record call args
	mmcancelTaskByKey.cancelTaskByKeyMock.mutex.Lock()
	mmcancelTaskByKey.cancelTaskByKeyMock.callArgs = append(mmcancelTaskByKey.cancelTaskByKeyMock.callArgs, mm_params)
	mmcancelTaskByKey.cancelTaskByKeyMock.mutex.Unlock()

	for _, e := range mmcancelTaskByKey.cancelTaskByKeyMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmcancelTaskByKey.cancelTaskByKeyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmcancelTaskByKey.cancelTaskByKeyMock.defaultExpectation.Counter, 1)
		mm_want := mmcancelTaskByKey.cancelTaskByKeyMock.defaultExpectation.params
		mm_got := StorageMockcancelTaskByKeyParams{ctx, kind, key, reason}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmcancelTaskByKey.t.Errorf("StorageMock.cancelTaskByKey got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmcancelTaskByKey.cancelTaskByKeyMock.defaultExpectation.results
		if mm_results == nil {
			mmcancelTaskByKey.t.Fatal("No results are set for the StorageMock.cancelTaskByKey")
		}
		return (*mm_results).err
	}
	if mmcancelTaskByKey.funccancelTaskByKey != nil {
		return mmcancelTaskByKey.funccancelTaskByKey(ctx, kind, key, reason)
	}
	mmcancelTaskByKey.t.Fatalf("Unexpected call to StorageMock.cancelTaskByKey. %v %v %v %v", ctx, kind, key, reason)
	return
}

// cancelTaskByKeyAfterCounter returns a count of finished StorageMock.cancelTaskByKey invocations
func (mmcancelTaskByKey *StorageMock) cancelTaskByKeyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmcancelTaskByKey.aftercancelTaskByKeyCounter)
}

// cancelTaskByKeyBeforeCounter returns a count of StorageMock.cancelTaskByKey invocations
func (mmcancelTaskByKey *StorageMock) cancelTaskByKeyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmcancelTaskByKey.beforecancelTaskByKeyCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.cancelTaskByKey.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmcancelTaskByKey *mStorageMockcancelTaskByKey) Calls() []*StorageMockcancelTaskByKeyParams {
	mmcancelTaskByKey.mutex.RLock()

	argCopy := make([]*StorageMockcancelTaskByKeyParams, len(mmcancelTaskByKey.callArgs))
	copy(argCopy, mmcancelTaskByKey.callArgs)

	mmcancelTaskByKey.mutex.RUnlock()

	return argCopy
}

// MinimockcancelTaskByKeyDone returns true if the count of the cancelTaskByKey invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockcancelTaskByKeyDone() bool {
	for _, e := range m.cancelTaskByKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.cancelTaskByKeyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.aftercancelTaskByKeyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funccancelTaskByKey != nil && mm_atomic.LoadUint64(&m.aftercancelTaskByKeyCounter) < 1 {
		return false
	}
	return true
}

// MinimockcancelTaskByKeyInspect logs each unmet expectation
func (m *StorageMock) MinimockcancelTaskByKeyInspect() {
	for _, e := range m.cancelTaskByKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.cancelTaskByKey with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.cancelTaskByKeyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.aftercancelTaskByKeyCounter) < 1 {
		if m.cancelTaskByKeyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.cancelTaskByKey")
		} else {
			m.t.Errorf("Expected call to StorageMock.cancelTaskByKey with params: %#v", *m.cancelTaskByKeyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funccancelTaskByKey != nil && mm_atomic.LoadUint64(&m.aftercancelTaskByKeyCounter) < 1 {
		m.t.Error("Expected call to StorageMock.cancelTaskByKey")
	}
}

type mStorageMockcloseExpiredTasks struct {
	mock               *StorageMock
	defaultExpectation *StorageMockcloseExpiredTasksExpectation
	expectations       []*StorageMockcloseExpiredTasksExpectation

	callArgs []*StorageMockcloseExpiredTasksParams
	mutex    sync.RWMutex
}

// StorageMockcloseExpiredTasksExpectation specifies expectation struct of the storage.closeExpiredTasks
type StorageMockcloseExpiredTasksExpectation struct {
	mock    *StorageMock
	params  *StorageMockcloseExpiredTasksParams
	results *StorageMockcloseExpiredTasksResults
	Counter uint64
}

// StorageMockcloseExpiredTasksParams contains parameters of the storage.closeExpiredTasks
type StorageMockcloseExpiredTasksParams struct {
	ctx  context.Context
	kind int16
}

// StorageMockcloseExpiredTasksResults contains results of the storage.closeExpiredTasks
type StorageMockcloseExpiredTasksResults struct {
	err error
}

// Expect sets up expected params for storage.closeExpiredTasks
func (mmcloseExpiredTasks *mStorageMockcloseExpiredTasks) Expect(ctx context.Context, kind int16) *mStorageMockcloseExpiredTasks {
	if mmcloseExpiredTasks.mock.funccloseExpiredTasks != nil {
		mmcloseExpiredTasks.mock.t.Fatalf("StorageMock.closeExpiredTasks mock is already set by Set")
	}

	if mmcloseExpiredTasks.defaultExpectation == nil {
		mmcloseExpiredTasks.defaultExpectation = &StorageMockcloseExpiredTasksExpectation{}
	}

	mmcloseExpiredTasks.defaultExpectation.params = &StorageMockcloseExpiredTasksParams{ctx, kind}
	for _, e := range mmcloseExpiredTasks.expectations {
		if minimock.Equal(e.params, mmcloseExpiredTasks.defaultExpectation.params) {
			mmcloseExpiredTasks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmcloseExpiredTasks.defaultExpectation.params)
		}
	}

	return mmcloseExpiredTasks
}

// Inspect accepts an inspector function that has same arguments as the storage.closeExpiredTasks
func (mmcloseExpiredTasks *mStorageMockcloseExpiredTasks) Inspect(f func(ctx context.Context, kind int16)) *mStorageMockcloseExpiredTasks {
	if mmcloseExpiredTasks.mock.inspectFunccloseExpiredTasks != nil {
		mmcloseExpiredTasks.mock.t.Fatalf("Inspect function is already set for StorageMock.closeExpiredTasks")
	}

	mmcloseExpiredTasks.mock.inspectFunccloseExpiredTasks = f

	return mmcloseExpiredTasks
}

// Return sets up results that will be returned by storage.closeExpiredTasks
func (mmcloseExpiredTasks *mStorageMockcloseExpiredTasks) Return(err error) *StorageMock {
	if mmcloseExpiredTasks.mock.funccloseExpiredTasks != nil {
		mmcloseExpiredTasks.mock.t.Fatalf("StorageMock.closeExpiredTasks mock is already set by Set")
	}

	if mmcloseExpiredTasks.defaultExpectation == nil {
		mmcloseExpiredTasks.defaultExpectation = &StorageMockcloseExpiredTasksExpectation{mock: mmcloseExpiredTasks.mock}
	}
	mmcloseExpiredTasks.defaultExpectation.results = &StorageMockcloseExpiredTasksResults{err}
	return mmcloseExpiredTasks.mock
}

// Set uses given function f to mock the storage.closeExpiredTasks method
func (mmcloseExpiredTasks *mStorageMockcloseExpiredTasks) Set(f func(ctx context.Context, kind int16) (err error)) *StorageMock {
	if mmcloseExpiredTasks.defaultExpectation != nil {
		mmcloseExpiredTasks.mock.t.Fatalf("Default expectation is already set for the storage.closeExpiredTasks method")
	}

	if len(mmcloseExpiredTasks.expectations) > 0 {
		mmcloseExpiredTasks.mock.t.Fatalf("Some expectations are already set for the storage.closeExpiredTasks method")
	}

	mmcloseExpiredTasks.mock.funccloseExpiredTasks = f
	return mmcloseExpiredTasks.mock
}

// When sets expectation for the storage.closeExpiredTasks which will trigger the result defined by the following
// Then helper
func (mmcloseExpiredTasks *mStorageMockcloseExpiredTasks) When(ctx context.Context, kind int16) *StorageMockcloseExpiredTasksExpectation {
	if mmcloseExpiredTasks.mock.funccloseExpiredTasks != nil {
		mmcloseExpiredTasks.mock.t.Fatalf("StorageMock.closeExpiredTasks mock is already set by Set")
	}

	expectation := &StorageMockcloseExpiredTasksExpectation{
		mock:   mmcloseExpiredTasks.mock,
		params: &StorageMockcloseExpiredTasksParams{ctx, kind},
	}
	mmcloseExpiredTasks.expectations = append(mmcloseExpiredTasks.expectations, expectation)
	return expectation
}

// Then sets up storage.closeExpiredTasks return parameters for the expectation previously defined by the When method
func (e *StorageMockcloseExpiredTasksExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockcloseExpiredTasksResults{err}
	return e.mock
}

// closeExpiredTasks implements storage
func (mmcloseExpiredTasks *StorageMock) closeExpiredTasks(ctx context.Context, kind int16) (err error) {
	mm_atomic.AddUint64(&mmcloseExpiredTasks.beforecloseExpiredTasksCounter, 1)
	defer mm_atomic.AddUint64(&mmcloseExpiredTasks.aftercloseExpiredTasksCounter, 1)

	if mmcloseExpiredTasks.inspectFunccloseExpiredTasks != nil {
		mmcloseExpiredTasks.inspectFunccloseExpiredTasks(ctx, kind)
	}

	mm_params := &StorageMockcloseExpiredTasksParams{ctx, kind}

	// Record call args
	mmcloseExpiredTasks.closeExpiredTasksMock.mutex.Lock()
	mmcloseExpiredTasks.closeExpiredTasksMock.callArgs = append(mmcloseExpiredTasks.closeExpiredTasksMock.callArgs, mm_params)
	mmcloseExpiredTasks.closeExpiredTasksMock.mutex.Unlock()

	for _, e := range mmcloseExpiredTasks.closeExpiredTasksMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmcloseExpiredTasks.closeExpiredTasksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmcloseExpiredTasks.closeExpiredTasksMock.defaultExpectation.Counter, 1)
		mm_want := mmcloseExpiredTasks.closeExpiredTasksMock.defaultExpectation.params
		mm_got := StorageMockcloseExpiredTasksParams{ctx, kind}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmcloseExpiredTasks.t.Errorf("StorageMock.closeExpiredTasks got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmcloseExpiredTasks.closeExpiredTasksMock.defaultExpectation.results
		if mm_results == nil {
			mmcloseExpiredTasks.t.Fatal("No results are set for the StorageMock.closeExpiredTasks")
		}
		return (*mm_results).err
	}
	if mmcloseExpiredTasks.funccloseExpiredTasks != nil {
		return mmcloseExpiredTasks.funccloseExpiredTasks(ctx, kind)
	}
	mmcloseExpiredTasks.t.Fatalf("Unexpected call to StorageMock.closeExpiredTasks. %v %v", ctx, kind)
	return
}

// closeExpiredTasksAfterCounter returns a count of finished StorageMock.closeExpiredTasks invocations
func (mmcloseExpiredTasks *StorageMock) closeExpiredTasksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmcloseExpiredTasks.aftercloseExpiredTasksCounter)
}

// closeExpiredTasksBeforeCounter returns a count of StorageMock.closeExpiredTasks invocations
func (mmcloseExpiredTasks *StorageMock) closeExpiredTasksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmcloseExpiredTasks.beforecloseExpiredTasksCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.closeExpiredTasks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmcloseExpiredTasks *mStorageMockcloseExpiredTasks) Calls() []*StorageMockcloseExpiredTasksParams {
	mmcloseExpiredTasks.mutex.RLock()

	argCopy := make([]*StorageMockcloseExpiredTasksParams, len(mmcloseExpiredTasks.callArgs))
	copy(argCopy, mmcloseExpiredTasks.callArgs)

	mmcloseExpiredTasks.mutex.RUnlock()

	return argCopy
}

// MinimockcloseExpiredTasksDone returns true if the count of the closeExpiredTasks invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockcloseExpiredTasksDone() bool {
	for _, e := range m.closeExpiredTasksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.closeExpiredTasksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.aftercloseExpiredTasksCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funccloseExpiredTasks != nil && mm_atomic.LoadUint64(&m.aftercloseExpiredTasksCounter) < 1 {
		return false
	}
	return true
}

// MinimockcloseExpiredTasksInspect logs each unmet expectation
func (m *StorageMock) MinimockcloseExpiredTasksInspect() {
	for _, e := range m.closeExpiredTasksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.closeExpiredTasks with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.closeExpiredTasksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.aftercloseExpiredTasksCounter) < 1 {
		if m.closeExpiredTasksMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.closeExpiredTasks")
		} else {
			m.t.Errorf("Expected call to StorageMock.closeExpiredTasks with params: %#v", *m.closeExpiredTasksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funccloseExpiredTasks != nil && mm_atomic.LoadUint64(&m.aftercloseExpiredTasksCounter) < 1 {
		m.t.Error("Expected call to StorageMock.closeExpiredTasks")
	}
}

type mStorageMockcompleteTask struct {
	mock               *StorageMock
	defaultExpectation *StorageMockcompleteTaskExpectation
	expectations       []*StorageMockcompleteTaskExpectation

	callArgs []*StorageMockcompleteTaskParams
	mutex    sync.RWMutex
}

// StorageMockcompleteTaskExpectation specifies expectation struct of the storage.completeTask
type StorageMockcompleteTaskExpectation struct {
	mock    *StorageMock
	params  *StorageMockcompleteTaskParams
	results *StorageMockcompleteTaskResults
	Counter uint64
}

// StorageMockcompleteTaskParams contains parameters of the storage.completeTask
type StorageMockcompleteTaskParams struct {
	ctx          context.Context
	id           int64
	delaySeconds uint32
}

// StorageMockcompleteTaskResults contains results of the storage.completeTask
type StorageMockcompleteTaskResults struct {
	err error
}

// Expect sets up expected params for storage.completeTask
func (mmcompleteTask *mStorageMockcompleteTask) Expect(ctx context.Context, id int64, delaySeconds uint32) *mStorageMockcompleteTask {
	if mmcompleteTask.mock.funccompleteTask != nil {
		mmcompleteTask.mock.t.Fatalf("StorageMock.completeTask mock is already set by Set")
	}

	if mmcompleteTask.defaultExpectation == nil {
		mmcompleteTask.defaultExpectation = &StorageMockcompleteTaskExpectation{}
	}

	mmcompleteTask.defaultExpectation.params = &StorageMockcompleteTaskParams{ctx, id, delaySeconds}
	for _, e := range mmcompleteTask.expectations {
		if minimock.Equal(e.params, mmcompleteTask.defaultExpectation.params) {
			mmcompleteTask.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmcompleteTask.defaultExpectation.params)
		}
	}

	return mmcompleteTask
}

// Inspect accepts an inspector function that has same arguments as the storage.completeTask
func (mmcompleteTask *mStorageMockcompleteTask) Inspect(f func(ctx context.Context, id int64, delaySeconds uint32)) *mStorageMockcompleteTask {
	if mmcompleteTask.mock.inspectFunccompleteTask != nil {
		mmcompleteTask.mock.t.Fatalf("Inspect function is already set for StorageMock.completeTask")
	}

	mmcompleteTask.mock.inspectFunccompleteTask = f

	return mmcompleteTask
}

// Return sets up results that will be returned by storage.completeTask
func (mmcompleteTask *mStorageMockcompleteTask) Return(err error) *StorageMock {
	if mmcompleteTask.mock.funccompleteTask != nil {
		mmcompleteTask.mock.t.Fatalf("StorageMock.completeTask mock is already set by Set")
	}

	if mmcompleteTask.defaultExpectation == nil {
		mmcompleteTask.defaultExpectation = &StorageMockcompleteTaskExpectation{mock: mmcompleteTask.mock}
	}
	mmcompleteTask.defaultExpectation.results = &StorageMockcompleteTaskResults{err}
	return mmcompleteTask.mock
}

// Set uses given function f to mock the storage.completeTask method
func (mmcompleteTask *mStorageMockcompleteTask) Set(f func(ctx context.Context, id int64, delaySeconds uint32) (err error)) *StorageMock {
	if mmcompleteTask.defaultExpectation != nil {
		mmcompleteTask.mock.t.Fatalf("Default expectation is already set for the storage.completeTask method")
	}

	if len(mmcompleteTask.expectations) > 0 {
		mmcompleteTask.mock.t.Fatalf("Some expectations are already set for the storage.completeTask method")
	}

	mmcompleteTask.mock.funccompleteTask = f
	return mmcompleteTask.mock
}

// When sets expectation for the storage.completeTask which will trigger the result defined by the following
// Then helper
func (mmcompleteTask *mStorageMockcompleteTask) When(ctx context.Context, id int64, delaySeconds uint32) *StorageMockcompleteTaskExpectation {
	if mmcompleteTask.mock.funccompleteTask != nil {
		mmcompleteTask.mock.t.Fatalf("StorageMock.completeTask mock is already set by Set")
	}

	expectation := &StorageMockcompleteTaskExpectation{
		mock:   mmcompleteTask.mock,
		params: &StorageMockcompleteTaskParams{ctx, id, delaySeconds},
	}
	mmcompleteTask.expectations = append(mmcompleteTask.expectations, expectation)
	return expectation
}

// Then sets up storage.completeTask return parameters for the expectation previously defined by the When method
func (e *StorageMockcompleteTaskExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockcompleteTaskResults{err}
	return e.mock
}

// completeTask implements storage
func (mmcompleteTask *StorageMock) completeTask(ctx context.Context, id int64, delaySeconds uint32) (err error) {
	mm_atomic.AddUint64(&mmcompleteTask.beforecompleteTaskCounter, 1)
	defer mm_atomic.AddUint64(&mmcompleteTask.aftercompleteTaskCounter, 1)

	if mmcompleteTask.inspectFunccompleteTask != nil {
		mmcompleteTask.inspectFunccompleteTask(ctx, id, delaySeconds)
	}

	mm_params := &StorageMockcompleteTaskParams{ctx, id, delaySeconds}

	// Record call args
	mmcompleteTask.completeTaskMock.mutex.Lock()
	mmcompleteTask.completeTaskMock.callArgs = append(mmcompleteTask.completeTaskMock.callArgs, mm_params)
	mmcompleteTask.completeTaskMock.mutex.Unlock()

	for _, e := range mmcompleteTask.completeTaskMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmcompleteTask.completeTaskMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmcompleteTask.completeTaskMock.defaultExpectation.Counter, 1)
		mm_want := mmcompleteTask.completeTaskMock.defaultExpectation.params
		mm_got := StorageMockcompleteTaskParams{ctx, id, delaySeconds}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmcompleteTask.t.Errorf("StorageMock.completeTask got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmcompleteTask.completeTaskMock.defaultExpectation.results
		if mm_results == nil {
			mmcompleteTask.t.Fatal("No results are set for the StorageMock.completeTask")
		}
		return (*mm_results).err
	}
	if mmcompleteTask.funccompleteTask != nil {
		return mmcompleteTask.funccompleteTask(ctx, id, delaySeconds)
	}
	mmcompleteTask.t.Fatalf("Unexpected call to StorageMock.completeTask. %v %v %v", ctx, id, delaySeconds)
	return
}

// completeTaskAfterCounter returns a count of finished StorageMock.completeTask invocations
func (mmcompleteTask *StorageMock) completeTaskAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmcompleteTask.aftercompleteTaskCounter)
}

// completeTaskBeforeCounter returns a count of StorageMock.completeTask invocations
func (mmcompleteTask *StorageMock) completeTaskBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmcompleteTask.beforecompleteTaskCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.completeTask.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmcompleteTask *mStorageMockcompleteTask) Calls() []*StorageMockcompleteTaskParams {
	mmcompleteTask.mutex.RLock()

	argCopy := make([]*StorageMockcompleteTaskParams, len(mmcompleteTask.callArgs))
	copy(argCopy, mmcompleteTask.callArgs)

	mmcompleteTask.mutex.RUnlock()

	return argCopy
}

// MinimockcompleteTaskDone returns true if the count of the completeTask invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockcompleteTaskDone() bool {
	for _, e := range m.completeTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.completeTaskMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.aftercompleteTaskCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funccompleteTask != nil && mm_atomic.LoadUint64(&m.aftercompleteTaskCounter) < 1 {
		return false
	}
	return true
}

// MinimockcompleteTaskInspect logs each unmet expectation
func (m *StorageMock) MinimockcompleteTaskInspect() {
	for _, e := range m.completeTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.completeTask with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.completeTaskMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.aftercompleteTaskCounter) < 1 {
		if m.completeTaskMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.completeTask")
		} else {
			m.t.Errorf("Expected call to StorageMock.completeTask with params: %#v", *m.completeTaskMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funccompleteTask != nil && mm_atomic.LoadUint64(&m.aftercompleteTaskCounter) < 1 {
		m.t.Error("Expected call to StorageMock.completeTask")
	}
}

type mStorageMockcreateTask struct {
	mock               *StorageMock
	defaultExpectation *StorageMockcreateTaskExpectation
	expectations       []*StorageMockcreateTaskExpectation

	callArgs []*StorageMockcreateTaskParams
	mutex    sync.RWMutex
}

// StorageMockcreateTaskExpectation specifies expectation struct of the storage.createTask
type StorageMockcreateTaskExpectation struct {
	mock    *StorageMock
	params  *StorageMockcreateTaskParams
	results *StorageMockcreateTaskResults
	Counter uint64
}

// StorageMockcreateTaskParams contains parameters of the storage.createTask
type StorageMockcreateTaskParams struct {
	ctx         context.Context
	kind        int16
	maxAttempts uint16
	payload     []byte
	ttlSeconds  uint32
	key         string
	delay       time.Duration
	endlessly   bool
}

// StorageMockcreateTaskResults contains results of the storage.createTask
type StorageMockcreateTaskResults struct {
	err error
}

// Expect sets up expected params for storage.createTask
func (mmcreateTask *mStorageMockcreateTask) Expect(ctx context.Context, kind int16, maxAttempts uint16, payload []byte, ttlSeconds uint32, key string, delay time.Duration, endlessly bool) *mStorageMockcreateTask {
	if mmcreateTask.mock.funccreateTask != nil {
		mmcreateTask.mock.t.Fatalf("StorageMock.createTask mock is already set by Set")
	}

	if mmcreateTask.defaultExpectation == nil {
		mmcreateTask.defaultExpectation = &StorageMockcreateTaskExpectation{}
	}

	mmcreateTask.defaultExpectation.params = &StorageMockcreateTaskParams{ctx, kind, maxAttempts, payload, ttlSeconds, key, delay, endlessly}
	for _, e := range mmcreateTask.expectations {
		if minimock.Equal(e.params, mmcreateTask.defaultExpectation.params) {
			mmcreateTask.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmcreateTask.defaultExpectation.params)
		}
	}

	return mmcreateTask
}

// Inspect accepts an inspector function that has same arguments as the storage.createTask
func (mmcreateTask *mStorageMockcreateTask) Inspect(f func(ctx context.Context, kind int16, maxAttempts uint16, payload []byte, ttlSeconds uint32, key string, delay time.Duration, endlessly bool)) *mStorageMockcreateTask {
	if mmcreateTask.mock.inspectFunccreateTask != nil {
		mmcreateTask.mock.t.Fatalf("Inspect function is already set for StorageMock.createTask")
	}

	mmcreateTask.mock.inspectFunccreateTask = f

	return mmcreateTask
}

// Return sets up results that will be returned by storage.createTask
func (mmcreateTask *mStorageMockcreateTask) Return(err error) *StorageMock {
	if mmcreateTask.mock.funccreateTask != nil {
		mmcreateTask.mock.t.Fatalf("StorageMock.createTask mock is already set by Set")
	}

	if mmcreateTask.defaultExpectation == nil {
		mmcreateTask.defaultExpectation = &StorageMockcreateTaskExpectation{mock: mmcreateTask.mock}
	}
	mmcreateTask.defaultExpectation.results = &StorageMockcreateTaskResults{err}
	return mmcreateTask.mock
}

// Set uses given function f to mock the storage.createTask method
func (mmcreateTask *mStorageMockcreateTask) Set(f func(ctx context.Context, kind int16, maxAttempts uint16, payload []byte, ttlSeconds uint32, key string, delay time.Duration, endlessly bool) (err error)) *StorageMock {
	if mmcreateTask.defaultExpectation != nil {
		mmcreateTask.mock.t.Fatalf("Default expectation is already set for the storage.createTask method")
	}

	if len(mmcreateTask.expectations) > 0 {
		mmcreateTask.mock.t.Fatalf("Some expectations are already set for the storage.createTask method")
	}

	mmcreateTask.mock.funccreateTask = f
	return mmcreateTask.mock
}

// When sets expectation for the storage.createTask which will trigger the result defined by the following
// Then helper
func (mmcreateTask *mStorageMockcreateTask) When(ctx context.Context, kind int16, maxAttempts uint16, payload []byte, ttlSeconds uint32, key string, delay time.Duration, endlessly bool) *StorageMockcreateTaskExpectation {
	if mmcreateTask.mock.funccreateTask != nil {
		mmcreateTask.mock.t.Fatalf("StorageMock.createTask mock is already set by Set")
	}

	expectation := &StorageMockcreateTaskExpectation{
		mock:   mmcreateTask.mock,
		params: &StorageMockcreateTaskParams{ctx, kind, maxAttempts, payload, ttlSeconds, key, delay, endlessly},
	}
	mmcreateTask.expectations = append(mmcreateTask.expectations, expectation)
	return expectation
}

// Then sets up storage.createTask return parameters for the expectation previously defined by the When method
func (e *StorageMockcreateTaskExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockcreateTaskResults{err}
	return e.mock
}

// createTask implements storage
func (mmcreateTask *StorageMock) createTask(ctx context.Context, kind int16, maxAttempts uint16, payload []byte, ttlSeconds uint32, key string, delay time.Duration, endlessly bool) (err error) {
	mm_atomic.AddUint64(&mmcreateTask.beforecreateTaskCounter, 1)
	defer mm_atomic.AddUint64(&mmcreateTask.aftercreateTaskCounter, 1)

	if mmcreateTask.inspectFunccreateTask != nil {
		mmcreateTask.inspectFunccreateTask(ctx, kind, maxAttempts, payload, ttlSeconds, key, delay, endlessly)
	}

	mm_params := &StorageMockcreateTaskParams{ctx, kind, maxAttempts, payload, ttlSeconds, key, delay, endlessly}

	// Record call args
	mmcreateTask.createTaskMock.mutex.Lock()
	mmcreateTask.createTaskMock.callArgs = append(mmcreateTask.createTaskMock.callArgs, mm_params)
	mmcreateTask.createTaskMock.mutex.Unlock()

	for _, e := range mmcreateTask.createTaskMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmcreateTask.createTaskMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmcreateTask.createTaskMock.defaultExpectation.Counter, 1)
		mm_want := mmcreateTask.createTaskMock.defaultExpectation.params
		mm_got := StorageMockcreateTaskParams{ctx, kind, maxAttempts, payload, ttlSeconds, key, delay, endlessly}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmcreateTask.t.Errorf("StorageMock.createTask got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmcreateTask.createTaskMock.defaultExpectation.results
		if mm_results == nil {
			mmcreateTask.t.Fatal("No results are set for the StorageMock.createTask")
		}
		return (*mm_results).err
	}
	if mmcreateTask.funccreateTask != nil {
		return mmcreateTask.funccreateTask(ctx, kind, maxAttempts, payload, ttlSeconds, key, delay, endlessly)
	}
	mmcreateTask.t.Fatalf("Unexpected call to StorageMock.createTask. %v %v %v %v %v %v %v %v", ctx, kind, maxAttempts, payload, ttlSeconds, key, delay, endlessly)
	return
}

// createTaskAfterCounter returns a count of finished StorageMock.createTask invocations
func (mmcreateTask *StorageMock) createTaskAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmcreateTask.aftercreateTaskCounter)
}

// createTaskBeforeCounter returns a count of StorageMock.createTask invocations
func (mmcreateTask *StorageMock) createTaskBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmcreateTask.beforecreateTaskCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.createTask.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmcreateTask *mStorageMockcreateTask) Calls() []*StorageMockcreateTaskParams {
	mmcreateTask.mutex.RLock()

	argCopy := make([]*StorageMockcreateTaskParams, len(mmcreateTask.callArgs))
	copy(argCopy, mmcreateTask.callArgs)

	mmcreateTask.mutex.RUnlock()

	return argCopy
}

// MinimockcreateTaskDone returns true if the count of the createTask invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockcreateTaskDone() bool {
	for _, e := range m.createTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.createTaskMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.aftercreateTaskCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funccreateTask != nil && mm_atomic.LoadUint64(&m.aftercreateTaskCounter) < 1 {
		return false
	}
	return true
}

// MinimockcreateTaskInspect logs each unmet expectation
func (m *StorageMock) MinimockcreateTaskInspect() {
	for _, e := range m.createTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.createTask with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.createTaskMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.aftercreateTaskCounter) < 1 {
		if m.createTaskMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.createTask")
		} else {
			m.t.Errorf("Expected call to StorageMock.createTask with params: %#v", *m.createTaskMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funccreateTask != nil && mm_atomic.LoadUint64(&m.aftercreateTaskCounter) < 1 {
		m.t.Error("Expected call to StorageMock.createTask")
	}
}

type mStorageMockcreateTaskTx struct {
	mock               *StorageMock
	defaultExpectation *StorageMockcreateTaskTxExpectation
	expectations       []*StorageMockcreateTaskTxExpectation

	callArgs []*StorageMockcreateTaskTxParams
	mutex    sync.RWMutex
}

// StorageMockcreateTaskTxExpectation specifies expectation struct of the storage.createTaskTx
type StorageMockcreateTaskTxExpectation struct {
	mock    *StorageMock
	params  *StorageMockcreateTaskTxParams
	results *StorageMockcreateTaskTxResults
	Counter uint64
}

// StorageMockcreateTaskTxParams contains parameters of the storage.createTaskTx
type StorageMockcreateTaskTxParams struct {
	ctx         context.Context
	tx          sqlx.Tx
	kind        int16
	maxAttempts uint16
	payload     []byte
	ttlSeconds  uint32
	key         string
	delay       time.Duration
	endlessly   bool
}

// StorageMockcreateTaskTxResults contains results of the storage.createTaskTx
type StorageMockcreateTaskTxResults struct {
	err error
}

// Expect sets up expected params for storage.createTaskTx
func (mmcreateTaskTx *mStorageMockcreateTaskTx) Expect(ctx context.Context, tx sqlx.Tx, kind int16, maxAttempts uint16, payload []byte, ttlSeconds uint32, key string, delay time.Duration, endlessly bool) *mStorageMockcreateTaskTx {
	if mmcreateTaskTx.mock.funccreateTaskTx != nil {
		mmcreateTaskTx.mock.t.Fatalf("StorageMock.createTaskTx mock is already set by Set")
	}

	if mmcreateTaskTx.defaultExpectation == nil {
		mmcreateTaskTx.defaultExpectation = &StorageMockcreateTaskTxExpectation{}
	}

	mmcreateTaskTx.defaultExpectation.params = &StorageMockcreateTaskTxParams{ctx, tx, kind, maxAttempts, payload, ttlSeconds, key, delay, endlessly}
	for _, e := range mmcreateTaskTx.expectations {
		if minimock.Equal(e.params, mmcreateTaskTx.defaultExpectation.params) {
			mmcreateTaskTx.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmcreateTaskTx.defaultExpectation.params)
		}
	}

	return mmcreateTaskTx
}

// Inspect accepts an inspector function that has same arguments as the storage.createTaskTx
func (mmcreateTaskTx *mStorageMockcreateTaskTx) Inspect(f func(ctx context.Context, tx sqlx.Tx, kind int16, maxAttempts uint16, payload []byte, ttlSeconds uint32, key string, delay time.Duration, endlessly bool)) *mStorageMockcreateTaskTx {
	if mmcreateTaskTx.mock.inspectFunccreateTaskTx != nil {
		mmcreateTaskTx.mock.t.Fatalf("Inspect function is already set for StorageMock.createTaskTx")
	}

	mmcreateTaskTx.mock.inspectFunccreateTaskTx = f

	return mmcreateTaskTx
}

// Return sets up results that will be returned by storage.createTaskTx
func (mmcreateTaskTx *mStorageMockcreateTaskTx) Return(err error) *StorageMock {
	if mmcreateTaskTx.mock.funccreateTaskTx != nil {
		mmcreateTaskTx.mock.t.Fatalf("StorageMock.createTaskTx mock is already set by Set")
	}

	if mmcreateTaskTx.defaultExpectation == nil {
		mmcreateTaskTx.defaultExpectation = &StorageMockcreateTaskTxExpectation{mock: mmcreateTaskTx.mock}
	}
	mmcreateTaskTx.defaultExpectation.results = &StorageMockcreateTaskTxResults{err}
	return mmcreateTaskTx.mock
}

// Set uses given function f to mock the storage.createTaskTx method
func (mmcreateTaskTx *mStorageMockcreateTaskTx) Set(f func(ctx context.Context, tx sqlx.Tx, kind int16, maxAttempts uint16, payload []byte, ttlSeconds uint32, key string, delay time.Duration, endlessly bool) (err error)) *StorageMock {
	if mmcreateTaskTx.defaultExpectation != nil {
		mmcreateTaskTx.mock.t.Fatalf("Default expectation is already set for the storage.createTaskTx method")
	}

	if len(mmcreateTaskTx.expectations) > 0 {
		mmcreateTaskTx.mock.t.Fatalf("Some expectations are already set for the storage.createTaskTx method")
	}

	mmcreateTaskTx.mock.funccreateTaskTx = f
	return mmcreateTaskTx.mock
}

// When sets expectation for the storage.createTaskTx which will trigger the result defined by the following
// Then helper
func (mmcreateTaskTx *mStorageMockcreateTaskTx) When(ctx context.Context, tx sqlx.Tx, kind int16, maxAttempts uint16, payload []byte, ttlSeconds uint32, key string, delay time.Duration, endlessly bool) *StorageMockcreateTaskTxExpectation {
	if mmcreateTaskTx.mock.funccreateTaskTx != nil {
		mmcreateTaskTx.mock.t.Fatalf("StorageMock.createTaskTx mock is already set by Set")
	}

	expectation := &StorageMockcreateTaskTxExpectation{
		mock:   mmcreateTaskTx.mock,
		params: &StorageMockcreateTaskTxParams{ctx, tx, kind, maxAttempts, payload, ttlSeconds, key, delay, endlessly},
	}
	mmcreateTaskTx.expectations = append(mmcreateTaskTx.expectations, expectation)
	return expectation
}

// Then sets up storage.createTaskTx return parameters for the expectation previously defined by the When method
func (e *StorageMockcreateTaskTxExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockcreateTaskTxResults{err}
	return e.mock
}

// createTaskTx implements storage
func (mmcreateTaskTx *StorageMock) createTaskTx(ctx context.Context, tx sqlx.Tx, kind int16, maxAttempts uint16, payload []byte, ttlSeconds uint32, key string, delay time.Duration, endlessly bool) (err error) {
	mm_atomic.AddUint64(&mmcreateTaskTx.beforecreateTaskTxCounter, 1)
	defer mm_atomic.AddUint64(&mmcreateTaskTx.aftercreateTaskTxCounter, 1)

	if mmcreateTaskTx.inspectFunccreateTaskTx != nil {
		mmcreateTaskTx.inspectFunccreateTaskTx(ctx, tx, kind, maxAttempts, payload, ttlSeconds, key, delay, endlessly)
	}

	mm_params := &StorageMockcreateTaskTxParams{ctx, tx, kind, maxAttempts, payload, ttlSeconds, key, delay, endlessly}

	// Record call args
	mmcreateTaskTx.createTaskTxMock.mutex.Lock()
	mmcreateTaskTx.createTaskTxMock.callArgs = append(mmcreateTaskTx.createTaskTxMock.callArgs, mm_params)
	mmcreateTaskTx.createTaskTxMock.mutex.Unlock()

	for _, e := range mmcreateTaskTx.createTaskTxMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmcreateTaskTx.createTaskTxMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmcreateTaskTx.createTaskTxMock.defaultExpectation.Counter, 1)
		mm_want := mmcreateTaskTx.createTaskTxMock.defaultExpectation.params
		mm_got := StorageMockcreateTaskTxParams{ctx, tx, kind, maxAttempts, payload, ttlSeconds, key, delay, endlessly}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmcreateTaskTx.t.Errorf("StorageMock.createTaskTx got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmcreateTaskTx.createTaskTxMock.defaultExpectation.results
		if mm_results == nil {
			mmcreateTaskTx.t.Fatal("No results are set for the StorageMock.createTaskTx")
		}
		return (*mm_results).err
	}
	if mmcreateTaskTx.funccreateTaskTx != nil {
		return mmcreateTaskTx.funccreateTaskTx(ctx, tx, kind, maxAttempts, payload, ttlSeconds, key, delay, endlessly)
	}
	mmcreateTaskTx.t.Fatalf("Unexpected call to StorageMock.createTaskTx. %v %v %v %v %v %v %v %v %v", ctx, tx, kind, maxAttempts, payload, ttlSeconds, key, delay, endlessly)
	return
}

// createTaskTxAfterCounter returns a count of finished StorageMock.createTaskTx invocations
func (mmcreateTaskTx *StorageMock) createTaskTxAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmcreateTaskTx.aftercreateTaskTxCounter)
}

// createTaskTxBeforeCounter returns a count of StorageMock.createTaskTx invocations
func (mmcreateTaskTx *StorageMock) createTaskTxBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmcreateTaskTx.beforecreateTaskTxCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.createTaskTx.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmcreateTaskTx *mStorageMockcreateTaskTx) Calls() []*StorageMockcreateTaskTxParams {
	mmcreateTaskTx.mutex.RLock()

	argCopy := make([]*StorageMockcreateTaskTxParams, len(mmcreateTaskTx.callArgs))
	copy(argCopy, mmcreateTaskTx.callArgs)

	mmcreateTaskTx.mutex.RUnlock()

	return argCopy
}

// MinimockcreateTaskTxDone returns true if the count of the createTaskTx invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockcreateTaskTxDone() bool {
	for _, e := range m.createTaskTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.createTaskTxMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.aftercreateTaskTxCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funccreateTaskTx != nil && mm_atomic.LoadUint64(&m.aftercreateTaskTxCounter) < 1 {
		return false
	}
	return true
}

// MinimockcreateTaskTxInspect logs each unmet expectation
func (m *StorageMock) MinimockcreateTaskTxInspect() {
	for _, e := range m.createTaskTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.createTaskTx with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.createTaskTxMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.aftercreateTaskTxCounter) < 1 {
		if m.createTaskTxMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.createTaskTx")
		} else {
			m.t.Errorf("Expected call to StorageMock.createTaskTx with params: %#v", *m.createTaskTxMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funccreateTaskTx != nil && mm_atomic.LoadUint64(&m.aftercreateTaskTxCounter) < 1 {
		m.t.Error("Expected call to StorageMock.createTaskTx")
	}
}

type mStorageMockgetTasks struct {
	mock               *StorageMock
	defaultExpectation *StorageMockgetTasksExpectation
	expectations       []*StorageMockgetTasksExpectation

	callArgs []*StorageMockgetTasksParams
	mutex    sync.RWMutex
}

// StorageMockgetTasksExpectation specifies expectation struct of the storage.getTasks
type StorageMockgetTasksExpectation struct {
	mock    *StorageMock
	params  *StorageMockgetTasksParams
	results *StorageMockgetTasksResults
	Counter uint64
}

// StorageMockgetTasksParams contains parameters of the storage.getTasks
type StorageMockgetTasksParams struct {
	ctx                          context.Context
	kind                         int16
	workerCountLimitForInstance  uint16
	workerCountLimitForQueueKind uint16
}

// StorageMockgetTasksResults contains results of the storage.getTasks
type StorageMockgetTasksResults struct {
	tpa1 []*Task
	err  error
}

// Expect sets up expected params for storage.getTasks
func (mmgetTasks *mStorageMockgetTasks) Expect(ctx context.Context, kind int16, workerCountLimitForInstance uint16, workerCountLimitForQueueKind uint16) *mStorageMockgetTasks {
	if mmgetTasks.mock.funcgetTasks != nil {
		mmgetTasks.mock.t.Fatalf("StorageMock.getTasks mock is already set by Set")
	}

	if mmgetTasks.defaultExpectation == nil {
		mmgetTasks.defaultExpectation = &StorageMockgetTasksExpectation{}
	}

	mmgetTasks.defaultExpectation.params = &StorageMockgetTasksParams{ctx, kind, workerCountLimitForInstance, workerCountLimitForQueueKind}
	for _, e := range mmgetTasks.expectations {
		if minimock.Equal(e.params, mmgetTasks.defaultExpectation.params) {
			mmgetTasks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmgetTasks.defaultExpectation.params)
		}
	}

	return mmgetTasks
}

// Inspect accepts an inspector function that has same arguments as the storage.getTasks
func (mmgetTasks *mStorageMockgetTasks) Inspect(f func(ctx context.Context, kind int16, workerCountLimitForInstance uint16, workerCountLimitForQueueKind uint16)) *mStorageMockgetTasks {
	if mmgetTasks.mock.inspectFuncgetTasks != nil {
		mmgetTasks.mock.t.Fatalf("Inspect function is already set for StorageMock.getTasks")
	}

	mmgetTasks.mock.inspectFuncgetTasks = f

	return mmgetTasks
}

// Return sets up results that will be returned by storage.getTasks
func (mmgetTasks *mStorageMockgetTasks) Return(tpa1 []*Task, err error) *StorageMock {
	if mmgetTasks.mock.funcgetTasks != nil {
		mmgetTasks.mock.t.Fatalf("StorageMock.getTasks mock is already set by Set")
	}

	if mmgetTasks.defaultExpectation == nil {
		mmgetTasks.defaultExpectation = &StorageMockgetTasksExpectation{mock: mmgetTasks.mock}
	}
	mmgetTasks.defaultExpectation.results = &StorageMockgetTasksResults{tpa1, err}
	return mmgetTasks.mock
}

// Set uses given function f to mock the storage.getTasks method
func (mmgetTasks *mStorageMockgetTasks) Set(f func(ctx context.Context, kind int16, workerCountLimitForInstance uint16, workerCountLimitForQueueKind uint16) (tpa1 []*Task, err error)) *StorageMock {
	if mmgetTasks.defaultExpectation != nil {
		mmgetTasks.mock.t.Fatalf("Default expectation is already set for the storage.getTasks method")
	}

	if len(mmgetTasks.expectations) > 0 {
		mmgetTasks.mock.t.Fatalf("Some expectations are already set for the storage.getTasks method")
	}

	mmgetTasks.mock.funcgetTasks = f
	return mmgetTasks.mock
}

// When sets expectation for the storage.getTasks which will trigger the result defined by the following
// Then helper
func (mmgetTasks *mStorageMockgetTasks) When(ctx context.Context, kind int16, workerCountLimitForInstance uint16, workerCountLimitForQueueKind uint16) *StorageMockgetTasksExpectation {
	if mmgetTasks.mock.funcgetTasks != nil {
		mmgetTasks.mock.t.Fatalf("StorageMock.getTasks mock is already set by Set")
	}

	expectation := &StorageMockgetTasksExpectation{
		mock:   mmgetTasks.mock,
		params: &StorageMockgetTasksParams{ctx, kind, workerCountLimitForInstance, workerCountLimitForQueueKind},
	}
	mmgetTasks.expectations = append(mmgetTasks.expectations, expectation)
	return expectation
}

// Then sets up storage.getTasks return parameters for the expectation previously defined by the When method
func (e *StorageMockgetTasksExpectation) Then(tpa1 []*Task, err error) *StorageMock {
	e.results = &StorageMockgetTasksResults{tpa1, err}
	return e.mock
}

// getTasks implements storage
func (mmgetTasks *StorageMock) getTasks(ctx context.Context, kind int16, workerCountLimitForInstance uint16, workerCountLimitForQueueKind uint16) (tpa1 []*Task, err error) {
	mm_atomic.AddUint64(&mmgetTasks.beforegetTasksCounter, 1)
	defer mm_atomic.AddUint64(&mmgetTasks.aftergetTasksCounter, 1)

	if mmgetTasks.inspectFuncgetTasks != nil {
		mmgetTasks.inspectFuncgetTasks(ctx, kind, workerCountLimitForInstance, workerCountLimitForQueueKind)
	}

	mm_params := &StorageMockgetTasksParams{ctx, kind, workerCountLimitForInstance, workerCountLimitForQueueKind}

	// Record call args
	mmgetTasks.getTasksMock.mutex.Lock()
	mmgetTasks.getTasksMock.callArgs = append(mmgetTasks.getTasksMock.callArgs, mm_params)
	mmgetTasks.getTasksMock.mutex.Unlock()

	for _, e := range mmgetTasks.getTasksMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tpa1, e.results.err
		}
	}

	if mmgetTasks.getTasksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmgetTasks.getTasksMock.defaultExpectation.Counter, 1)
		mm_want := mmgetTasks.getTasksMock.defaultExpectation.params
		mm_got := StorageMockgetTasksParams{ctx, kind, workerCountLimitForInstance, workerCountLimitForQueueKind}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmgetTasks.t.Errorf("StorageMock.getTasks got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmgetTasks.getTasksMock.defaultExpectation.results
		if mm_results == nil {
			mmgetTasks.t.Fatal("No results are set for the StorageMock.getTasks")
		}
		return (*mm_results).tpa1, (*mm_results).err
	}
	if mmgetTasks.funcgetTasks != nil {
		return mmgetTasks.funcgetTasks(ctx, kind, workerCountLimitForInstance, workerCountLimitForQueueKind)
	}
	mmgetTasks.t.Fatalf("Unexpected call to StorageMock.getTasks. %v %v %v %v", ctx, kind, workerCountLimitForInstance, workerCountLimitForQueueKind)
	return
}

// getTasksAfterCounter returns a count of finished StorageMock.getTasks invocations
func (mmgetTasks *StorageMock) getTasksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmgetTasks.aftergetTasksCounter)
}

// getTasksBeforeCounter returns a count of StorageMock.getTasks invocations
func (mmgetTasks *StorageMock) getTasksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmgetTasks.beforegetTasksCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.getTasks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmgetTasks *mStorageMockgetTasks) Calls() []*StorageMockgetTasksParams {
	mmgetTasks.mutex.RLock()

	argCopy := make([]*StorageMockgetTasksParams, len(mmgetTasks.callArgs))
	copy(argCopy, mmgetTasks.callArgs)

	mmgetTasks.mutex.RUnlock()

	return argCopy
}

// MinimockgetTasksDone returns true if the count of the getTasks invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockgetTasksDone() bool {
	for _, e := range m.getTasksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.getTasksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.aftergetTasksCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcgetTasks != nil && mm_atomic.LoadUint64(&m.aftergetTasksCounter) < 1 {
		return false
	}
	return true
}

// MinimockgetTasksInspect logs each unmet expectation
func (m *StorageMock) MinimockgetTasksInspect() {
	for _, e := range m.getTasksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.getTasks with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.getTasksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.aftergetTasksCounter) < 1 {
		if m.getTasksMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.getTasks")
		} else {
			m.t.Errorf("Expected call to StorageMock.getTasks with params: %#v", *m.getTasksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcgetTasks != nil && mm_atomic.LoadUint64(&m.aftergetTasksCounter) < 1 {
		m.t.Error("Expected call to StorageMock.getTasks")
	}
}

type mStorageMockrefuseTask struct {
	mock               *StorageMock
	defaultExpectation *StorageMockrefuseTaskExpectation
	expectations       []*StorageMockrefuseTaskExpectation

	callArgs []*StorageMockrefuseTaskParams
	mutex    sync.RWMutex
}

// StorageMockrefuseTaskExpectation specifies expectation struct of the storage.refuseTask
type StorageMockrefuseTaskExpectation struct {
	mock    *StorageMock
	params  *StorageMockrefuseTaskParams
	results *StorageMockrefuseTaskResults
	Counter uint64
}

// StorageMockrefuseTaskParams contains parameters of the storage.refuseTask
type StorageMockrefuseTaskParams struct {
	ctx          context.Context
	id           int64
	reason       string
	delaySeconds uint32
}

// StorageMockrefuseTaskResults contains results of the storage.refuseTask
type StorageMockrefuseTaskResults struct {
	err error
}

// Expect sets up expected params for storage.refuseTask
func (mmrefuseTask *mStorageMockrefuseTask) Expect(ctx context.Context, id int64, reason string, delaySeconds uint32) *mStorageMockrefuseTask {
	if mmrefuseTask.mock.funcrefuseTask != nil {
		mmrefuseTask.mock.t.Fatalf("StorageMock.refuseTask mock is already set by Set")
	}

	if mmrefuseTask.defaultExpectation == nil {
		mmrefuseTask.defaultExpectation = &StorageMockrefuseTaskExpectation{}
	}

	mmrefuseTask.defaultExpectation.params = &StorageMockrefuseTaskParams{ctx, id, reason, delaySeconds}
	for _, e := range mmrefuseTask.expectations {
		if minimock.Equal(e.params, mmrefuseTask.defaultExpectation.params) {
			mmrefuseTask.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmrefuseTask.defaultExpectation.params)
		}
	}

	return mmrefuseTask
}

// Inspect accepts an inspector function that has same arguments as the storage.refuseTask
func (mmrefuseTask *mStorageMockrefuseTask) Inspect(f func(ctx context.Context, id int64, reason string, delaySeconds uint32)) *mStorageMockrefuseTask {
	if mmrefuseTask.mock.inspectFuncrefuseTask != nil {
		mmrefuseTask.mock.t.Fatalf("Inspect function is already set for StorageMock.refuseTask")
	}

	mmrefuseTask.mock.inspectFuncrefuseTask = f

	return mmrefuseTask
}

// Return sets up results that will be returned by storage.refuseTask
func (mmrefuseTask *mStorageMockrefuseTask) Return(err error) *StorageMock {
	if mmrefuseTask.mock.funcrefuseTask != nil {
		mmrefuseTask.mock.t.Fatalf("StorageMock.refuseTask mock is already set by Set")
	}

	if mmrefuseTask.defaultExpectation == nil {
		mmrefuseTask.defaultExpectation = &StorageMockrefuseTaskExpectation{mock: mmrefuseTask.mock}
	}
	mmrefuseTask.defaultExpectation.results = &StorageMockrefuseTaskResults{err}
	return mmrefuseTask.mock
}

// Set uses given function f to mock the storage.refuseTask method
func (mmrefuseTask *mStorageMockrefuseTask) Set(f func(ctx context.Context, id int64, reason string, delaySeconds uint32) (err error)) *StorageMock {
	if mmrefuseTask.defaultExpectation != nil {
		mmrefuseTask.mock.t.Fatalf("Default expectation is already set for the storage.refuseTask method")
	}

	if len(mmrefuseTask.expectations) > 0 {
		mmrefuseTask.mock.t.Fatalf("Some expectations are already set for the storage.refuseTask method")
	}

	mmrefuseTask.mock.funcrefuseTask = f
	return mmrefuseTask.mock
}

// When sets expectation for the storage.refuseTask which will trigger the result defined by the following
// Then helper
func (mmrefuseTask *mStorageMockrefuseTask) When(ctx context.Context, id int64, reason string, delaySeconds uint32) *StorageMockrefuseTaskExpectation {
	if mmrefuseTask.mock.funcrefuseTask != nil {
		mmrefuseTask.mock.t.Fatalf("StorageMock.refuseTask mock is already set by Set")
	}

	expectation := &StorageMockrefuseTaskExpectation{
		mock:   mmrefuseTask.mock,
		params: &StorageMockrefuseTaskParams{ctx, id, reason, delaySeconds},
	}
	mmrefuseTask.expectations = append(mmrefuseTask.expectations, expectation)
	return expectation
}

// Then sets up storage.refuseTask return parameters for the expectation previously defined by the When method
func (e *StorageMockrefuseTaskExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockrefuseTaskResults{err}
	return e.mock
}

// refuseTask implements storage
func (mmrefuseTask *StorageMock) refuseTask(ctx context.Context, id int64, reason string, delaySeconds uint32) (err error) {
	mm_atomic.AddUint64(&mmrefuseTask.beforerefuseTaskCounter, 1)
	defer mm_atomic.AddUint64(&mmrefuseTask.afterrefuseTaskCounter, 1)

	if mmrefuseTask.inspectFuncrefuseTask != nil {
		mmrefuseTask.inspectFuncrefuseTask(ctx, id, reason, delaySeconds)
	}

	mm_params := &StorageMockrefuseTaskParams{ctx, id, reason, delaySeconds}

	// Record call args
	mmrefuseTask.refuseTaskMock.mutex.Lock()
	mmrefuseTask.refuseTaskMock.callArgs = append(mmrefuseTask.refuseTaskMock.callArgs, mm_params)
	mmrefuseTask.refuseTaskMock.mutex.Unlock()

	for _, e := range mmrefuseTask.refuseTaskMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmrefuseTask.refuseTaskMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmrefuseTask.refuseTaskMock.defaultExpectation.Counter, 1)
		mm_want := mmrefuseTask.refuseTaskMock.defaultExpectation.params
		mm_got := StorageMockrefuseTaskParams{ctx, id, reason, delaySeconds}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmrefuseTask.t.Errorf("StorageMock.refuseTask got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmrefuseTask.refuseTaskMock.defaultExpectation.results
		if mm_results == nil {
			mmrefuseTask.t.Fatal("No results are set for the StorageMock.refuseTask")
		}
		return (*mm_results).err
	}
	if mmrefuseTask.funcrefuseTask != nil {
		return mmrefuseTask.funcrefuseTask(ctx, id, reason, delaySeconds)
	}
	mmrefuseTask.t.Fatalf("Unexpected call to StorageMock.refuseTask. %v %v %v %v", ctx, id, reason, delaySeconds)
	return
}

// refuseTaskAfterCounter returns a count of finished StorageMock.refuseTask invocations
func (mmrefuseTask *StorageMock) refuseTaskAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmrefuseTask.afterrefuseTaskCounter)
}

// refuseTaskBeforeCounter returns a count of StorageMock.refuseTask invocations
func (mmrefuseTask *StorageMock) refuseTaskBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmrefuseTask.beforerefuseTaskCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.refuseTask.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmrefuseTask *mStorageMockrefuseTask) Calls() []*StorageMockrefuseTaskParams {
	mmrefuseTask.mutex.RLock()

	argCopy := make([]*StorageMockrefuseTaskParams, len(mmrefuseTask.callArgs))
	copy(argCopy, mmrefuseTask.callArgs)

	mmrefuseTask.mutex.RUnlock()

	return argCopy
}

// MinimockrefuseTaskDone returns true if the count of the refuseTask invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockrefuseTaskDone() bool {
	for _, e := range m.refuseTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.refuseTaskMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterrefuseTaskCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcrefuseTask != nil && mm_atomic.LoadUint64(&m.afterrefuseTaskCounter) < 1 {
		return false
	}
	return true
}

// MinimockrefuseTaskInspect logs each unmet expectation
func (m *StorageMock) MinimockrefuseTaskInspect() {
	for _, e := range m.refuseTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.refuseTask with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.refuseTaskMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterrefuseTaskCounter) < 1 {
		if m.refuseTaskMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.refuseTask")
		} else {
			m.t.Errorf("Expected call to StorageMock.refuseTask with params: %#v", *m.refuseTaskMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcrefuseTask != nil && mm_atomic.LoadUint64(&m.afterrefuseTaskCounter) < 1 {
		m.t.Error("Expected call to StorageMock.refuseTask")
	}
}

type mStorageMockrepairLostTasks struct {
	mock               *StorageMock
	defaultExpectation *StorageMockrepairLostTasksExpectation
	expectations       []*StorageMockrepairLostTasksExpectation

	callArgs []*StorageMockrepairLostTasksParams
	mutex    sync.RWMutex
}

// StorageMockrepairLostTasksExpectation specifies expectation struct of the storage.repairLostTasks
type StorageMockrepairLostTasksExpectation struct {
	mock    *StorageMock
	params  *StorageMockrepairLostTasksParams
	results *StorageMockrepairLostTasksResults
	Counter uint64
}

// StorageMockrepairLostTasksParams contains parameters of the storage.repairLostTasks
type StorageMockrepairLostTasksParams struct {
	ctx         context.Context
	kind        int16
	lossSeconds uint32
}

// StorageMockrepairLostTasksResults contains results of the storage.repairLostTasks
type StorageMockrepairLostTasksResults struct {
	err error
}

// Expect sets up expected params for storage.repairLostTasks
func (mmrepairLostTasks *mStorageMockrepairLostTasks) Expect(ctx context.Context, kind int16, lossSeconds uint32) *mStorageMockrepairLostTasks {
	if mmrepairLostTasks.mock.funcrepairLostTasks != nil {
		mmrepairLostTasks.mock.t.Fatalf("StorageMock.repairLostTasks mock is already set by Set")
	}

	if mmrepairLostTasks.defaultExpectation == nil {
		mmrepairLostTasks.defaultExpectation = &StorageMockrepairLostTasksExpectation{}
	}

	mmrepairLostTasks.defaultExpectation.params = &StorageMockrepairLostTasksParams{ctx, kind, lossSeconds}
	for _, e := range mmrepairLostTasks.expectations {
		if minimock.Equal(e.params, mmrepairLostTasks.defaultExpectation.params) {
			mmrepairLostTasks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmrepairLostTasks.defaultExpectation.params)
		}
	}

	return mmrepairLostTasks
}

// Inspect accepts an inspector function that has same arguments as the storage.repairLostTasks
func (mmrepairLostTasks *mStorageMockrepairLostTasks) Inspect(f func(ctx context.Context, kind int16, lossSeconds uint32)) *mStorageMockrepairLostTasks {
	if mmrepairLostTasks.mock.inspectFuncrepairLostTasks != nil {
		mmrepairLostTasks.mock.t.Fatalf("Inspect function is already set for StorageMock.repairLostTasks")
	}

	mmrepairLostTasks.mock.inspectFuncrepairLostTasks = f

	return mmrepairLostTasks
}

// Return sets up results that will be returned by storage.repairLostTasks
func (mmrepairLostTasks *mStorageMockrepairLostTasks) Return(err error) *StorageMock {
	if mmrepairLostTasks.mock.funcrepairLostTasks != nil {
		mmrepairLostTasks.mock.t.Fatalf("StorageMock.repairLostTasks mock is already set by Set")
	}

	if mmrepairLostTasks.defaultExpectation == nil {
		mmrepairLostTasks.defaultExpectation = &StorageMockrepairLostTasksExpectation{mock: mmrepairLostTasks.mock}
	}
	mmrepairLostTasks.defaultExpectation.results = &StorageMockrepairLostTasksResults{err}
	return mmrepairLostTasks.mock
}

// Set uses given function f to mock the storage.repairLostTasks method
func (mmrepairLostTasks *mStorageMockrepairLostTasks) Set(f func(ctx context.Context, kind int16, lossSeconds uint32) (err error)) *StorageMock {
	if mmrepairLostTasks.defaultExpectation != nil {
		mmrepairLostTasks.mock.t.Fatalf("Default expectation is already set for the storage.repairLostTasks method")
	}

	if len(mmrepairLostTasks.expectations) > 0 {
		mmrepairLostTasks.mock.t.Fatalf("Some expectations are already set for the storage.repairLostTasks method")
	}

	mmrepairLostTasks.mock.funcrepairLostTasks = f
	return mmrepairLostTasks.mock
}

// When sets expectation for the storage.repairLostTasks which will trigger the result defined by the following
// Then helper
func (mmrepairLostTasks *mStorageMockrepairLostTasks) When(ctx context.Context, kind int16, lossSeconds uint32) *StorageMockrepairLostTasksExpectation {
	if mmrepairLostTasks.mock.funcrepairLostTasks != nil {
		mmrepairLostTasks.mock.t.Fatalf("StorageMock.repairLostTasks mock is already set by Set")
	}

	expectation := &StorageMockrepairLostTasksExpectation{
		mock:   mmrepairLostTasks.mock,
		params: &StorageMockrepairLostTasksParams{ctx, kind, lossSeconds},
	}
	mmrepairLostTasks.expectations = append(mmrepairLostTasks.expectations, expectation)
	return expectation
}

// Then sets up storage.repairLostTasks return parameters for the expectation previously defined by the When method
func (e *StorageMockrepairLostTasksExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockrepairLostTasksResults{err}
	return e.mock
}

// repairLostTasks implements storage
func (mmrepairLostTasks *StorageMock) repairLostTasks(ctx context.Context, kind int16, lossSeconds uint32) (err error) {
	mm_atomic.AddUint64(&mmrepairLostTasks.beforerepairLostTasksCounter, 1)
	defer mm_atomic.AddUint64(&mmrepairLostTasks.afterrepairLostTasksCounter, 1)

	if mmrepairLostTasks.inspectFuncrepairLostTasks != nil {
		mmrepairLostTasks.inspectFuncrepairLostTasks(ctx, kind, lossSeconds)
	}

	mm_params := &StorageMockrepairLostTasksParams{ctx, kind, lossSeconds}

	// Record call args
	mmrepairLostTasks.repairLostTasksMock.mutex.Lock()
	mmrepairLostTasks.repairLostTasksMock.callArgs = append(mmrepairLostTasks.repairLostTasksMock.callArgs, mm_params)
	mmrepairLostTasks.repairLostTasksMock.mutex.Unlock()

	for _, e := range mmrepairLostTasks.repairLostTasksMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmrepairLostTasks.repairLostTasksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmrepairLostTasks.repairLostTasksMock.defaultExpectation.Counter, 1)
		mm_want := mmrepairLostTasks.repairLostTasksMock.defaultExpectation.params
		mm_got := StorageMockrepairLostTasksParams{ctx, kind, lossSeconds}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmrepairLostTasks.t.Errorf("StorageMock.repairLostTasks got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmrepairLostTasks.repairLostTasksMock.defaultExpectation.results
		if mm_results == nil {
			mmrepairLostTasks.t.Fatal("No results are set for the StorageMock.repairLostTasks")
		}
		return (*mm_results).err
	}
	if mmrepairLostTasks.funcrepairLostTasks != nil {
		return mmrepairLostTasks.funcrepairLostTasks(ctx, kind, lossSeconds)
	}
	mmrepairLostTasks.t.Fatalf("Unexpected call to StorageMock.repairLostTasks. %v %v %v", ctx, kind, lossSeconds)
	return
}

// repairLostTasksAfterCounter returns a count of finished StorageMock.repairLostTasks invocations
func (mmrepairLostTasks *StorageMock) repairLostTasksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmrepairLostTasks.afterrepairLostTasksCounter)
}

// repairLostTasksBeforeCounter returns a count of StorageMock.repairLostTasks invocations
func (mmrepairLostTasks *StorageMock) repairLostTasksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmrepairLostTasks.beforerepairLostTasksCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.repairLostTasks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmrepairLostTasks *mStorageMockrepairLostTasks) Calls() []*StorageMockrepairLostTasksParams {
	mmrepairLostTasks.mutex.RLock()

	argCopy := make([]*StorageMockrepairLostTasksParams, len(mmrepairLostTasks.callArgs))
	copy(argCopy, mmrepairLostTasks.callArgs)

	mmrepairLostTasks.mutex.RUnlock()

	return argCopy
}

// MinimockrepairLostTasksDone returns true if the count of the repairLostTasks invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockrepairLostTasksDone() bool {
	for _, e := range m.repairLostTasksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.repairLostTasksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterrepairLostTasksCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcrepairLostTasks != nil && mm_atomic.LoadUint64(&m.afterrepairLostTasksCounter) < 1 {
		return false
	}
	return true
}

// MinimockrepairLostTasksInspect logs each unmet expectation
func (m *StorageMock) MinimockrepairLostTasksInspect() {
	for _, e := range m.repairLostTasksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.repairLostTasks with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.repairLostTasksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterrepairLostTasksCounter) < 1 {
		if m.repairLostTasksMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.repairLostTasks")
		} else {
			m.t.Errorf("Expected call to StorageMock.repairLostTasks with params: %#v", *m.repairLostTasksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcrepairLostTasks != nil && mm_atomic.LoadUint64(&m.afterrepairLostTasksCounter) < 1 {
		m.t.Error("Expected call to StorageMock.repairLostTasks")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StorageMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockabortTaskInspect()

		m.MinimockaddRetriesToFailedTasksInspect()

		m.MinimockarchiveClosedTasksInspect()

		m.MinimockcancelTaskByKeyInspect()

		m.MinimockcloseExpiredTasksInspect()

		m.MinimockcompleteTaskInspect()

		m.MinimockcreateTaskInspect()

		m.MinimockcreateTaskTxInspect()

		m.MinimockgetTasksInspect()

		m.MinimockrefuseTaskInspect()

		m.MinimockrepairLostTasksInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockabortTaskDone() &&
		m.MinimockaddRetriesToFailedTasksDone() &&
		m.MinimockarchiveClosedTasksDone() &&
		m.MinimockcancelTaskByKeyDone() &&
		m.MinimockcloseExpiredTasksDone() &&
		m.MinimockcompleteTaskDone() &&
		m.MinimockcreateTaskDone() &&
		m.MinimockcreateTaskTxDone() &&
		m.MinimockgetTasksDone() &&
		m.MinimockrefuseTaskDone() &&
		m.MinimockrepairLostTasksDone()
}
