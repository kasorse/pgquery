package pgqueue

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/kasorse/pgqueue.workerMonitor -o ./worker_monitor_mock_test.go -n WorkerMonitorMock

import (
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// WorkerMonitorMock implements workerMonitor
type WorkerMonitorMock struct {
	t minimock.Tester

	funcdecreaseRestingCount          func()
	inspectFuncdecreaseRestingCount   func()
	afterdecreaseRestingCountCounter  uint64
	beforedecreaseRestingCountCounter uint64
	decreaseRestingCountMock          mWorkerMonitorMockdecreaseRestingCount

	funcgetRestingCount          func() (u1 uint16)
	inspectFuncgetRestingCount   func()
	aftergetRestingCountCounter  uint64
	beforegetRestingCountCounter uint64
	getRestingCountMock          mWorkerMonitorMockgetRestingCount

	funcincreaseRestingCount          func()
	inspectFuncincreaseRestingCount   func()
	afterincreaseRestingCountCounter  uint64
	beforeincreaseRestingCountCounter uint64
	increaseRestingCountMock          mWorkerMonitorMockincreaseRestingCount
}

// NewWorkerMonitorMock returns a mock for workerMonitor
func NewWorkerMonitorMock(t minimock.Tester) *WorkerMonitorMock {
	m := &WorkerMonitorMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.decreaseRestingCountMock = mWorkerMonitorMockdecreaseRestingCount{mock: m}

	m.getRestingCountMock = mWorkerMonitorMockgetRestingCount{mock: m}

	m.increaseRestingCountMock = mWorkerMonitorMockincreaseRestingCount{mock: m}

	return m
}

type mWorkerMonitorMockdecreaseRestingCount struct {
	mock               *WorkerMonitorMock
	defaultExpectation *WorkerMonitorMockdecreaseRestingCountExpectation
	expectations       []*WorkerMonitorMockdecreaseRestingCountExpectation
}

// WorkerMonitorMockdecreaseRestingCountExpectation specifies expectation struct of the workerMonitor.decreaseRestingCount
type WorkerMonitorMockdecreaseRestingCountExpectation struct {
	mock *WorkerMonitorMock

	Counter uint64
}

// Expect sets up expected params for workerMonitor.decreaseRestingCount
func (mmdecreaseRestingCount *mWorkerMonitorMockdecreaseRestingCount) Expect() *mWorkerMonitorMockdecreaseRestingCount {
	if mmdecreaseRestingCount.mock.funcdecreaseRestingCount != nil {
		mmdecreaseRestingCount.mock.t.Fatalf("WorkerMonitorMock.decreaseRestingCount mock is already set by Set")
	}

	if mmdecreaseRestingCount.defaultExpectation == nil {
		mmdecreaseRestingCount.defaultExpectation = &WorkerMonitorMockdecreaseRestingCountExpectation{}
	}

	return mmdecreaseRestingCount
}

// Inspect accepts an inspector function that has same arguments as the workerMonitor.decreaseRestingCount
func (mmdecreaseRestingCount *mWorkerMonitorMockdecreaseRestingCount) Inspect(f func()) *mWorkerMonitorMockdecreaseRestingCount {
	if mmdecreaseRestingCount.mock.inspectFuncdecreaseRestingCount != nil {
		mmdecreaseRestingCount.mock.t.Fatalf("Inspect function is already set for WorkerMonitorMock.decreaseRestingCount")
	}

	mmdecreaseRestingCount.mock.inspectFuncdecreaseRestingCount = f

	return mmdecreaseRestingCount
}

// Return sets up results that will be returned by workerMonitor.decreaseRestingCount
func (mmdecreaseRestingCount *mWorkerMonitorMockdecreaseRestingCount) Return() *WorkerMonitorMock {
	if mmdecreaseRestingCount.mock.funcdecreaseRestingCount != nil {
		mmdecreaseRestingCount.mock.t.Fatalf("WorkerMonitorMock.decreaseRestingCount mock is already set by Set")
	}

	if mmdecreaseRestingCount.defaultExpectation == nil {
		mmdecreaseRestingCount.defaultExpectation = &WorkerMonitorMockdecreaseRestingCountExpectation{mock: mmdecreaseRestingCount.mock}
	}

	return mmdecreaseRestingCount.mock
}

// Set uses given function f to mock the workerMonitor.decreaseRestingCount method
func (mmdecreaseRestingCount *mWorkerMonitorMockdecreaseRestingCount) Set(f func()) *WorkerMonitorMock {
	if mmdecreaseRestingCount.defaultExpectation != nil {
		mmdecreaseRestingCount.mock.t.Fatalf("Default expectation is already set for the workerMonitor.decreaseRestingCount method")
	}

	if len(mmdecreaseRestingCount.expectations) > 0 {
		mmdecreaseRestingCount.mock.t.Fatalf("Some expectations are already set for the workerMonitor.decreaseRestingCount method")
	}

	mmdecreaseRestingCount.mock.funcdecreaseRestingCount = f
	return mmdecreaseRestingCount.mock
}

// decreaseRestingCount implements workerMonitor
func (mmdecreaseRestingCount *WorkerMonitorMock) decreaseRestingCount() {
	mm_atomic.AddUint64(&mmdecreaseRestingCount.beforedecreaseRestingCountCounter, 1)
	defer mm_atomic.AddUint64(&mmdecreaseRestingCount.afterdecreaseRestingCountCounter, 1)

	if mmdecreaseRestingCount.inspectFuncdecreaseRestingCount != nil {
		mmdecreaseRestingCount.inspectFuncdecreaseRestingCount()
	}

	if mmdecreaseRestingCount.decreaseRestingCountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmdecreaseRestingCount.decreaseRestingCountMock.defaultExpectation.Counter, 1)

		return

	}
	if mmdecreaseRestingCount.funcdecreaseRestingCount != nil {
		mmdecreaseRestingCount.funcdecreaseRestingCount()
		return
	}
	mmdecreaseRestingCount.t.Fatalf("Unexpected call to WorkerMonitorMock.decreaseRestingCount.")

}

// decreaseRestingCountAfterCounter returns a count of finished WorkerMonitorMock.decreaseRestingCount invocations
func (mmdecreaseRestingCount *WorkerMonitorMock) decreaseRestingCountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmdecreaseRestingCount.afterdecreaseRestingCountCounter)
}

// decreaseRestingCountBeforeCounter returns a count of WorkerMonitorMock.decreaseRestingCount invocations
func (mmdecreaseRestingCount *WorkerMonitorMock) decreaseRestingCountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmdecreaseRestingCount.beforedecreaseRestingCountCounter)
}

// MinimockdecreaseRestingCountDone returns true if the count of the decreaseRestingCount invocations corresponds
// the number of defined expectations
func (m *WorkerMonitorMock) MinimockdecreaseRestingCountDone() bool {
	for _, e := range m.decreaseRestingCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.decreaseRestingCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterdecreaseRestingCountCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcdecreaseRestingCount != nil && mm_atomic.LoadUint64(&m.afterdecreaseRestingCountCounter) < 1 {
		return false
	}
	return true
}

// MinimockdecreaseRestingCountInspect logs each unmet expectation
func (m *WorkerMonitorMock) MinimockdecreaseRestingCountInspect() {
	for _, e := range m.decreaseRestingCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to WorkerMonitorMock.decreaseRestingCount")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.decreaseRestingCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterdecreaseRestingCountCounter) < 1 {
		m.t.Error("Expected call to WorkerMonitorMock.decreaseRestingCount")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcdecreaseRestingCount != nil && mm_atomic.LoadUint64(&m.afterdecreaseRestingCountCounter) < 1 {
		m.t.Error("Expected call to WorkerMonitorMock.decreaseRestingCount")
	}
}

type mWorkerMonitorMockgetRestingCount struct {
	mock               *WorkerMonitorMock
	defaultExpectation *WorkerMonitorMockgetRestingCountExpectation
	expectations       []*WorkerMonitorMockgetRestingCountExpectation
}

// WorkerMonitorMockgetRestingCountExpectation specifies expectation struct of the workerMonitor.getRestingCount
type WorkerMonitorMockgetRestingCountExpectation struct {
	mock *WorkerMonitorMock

	results *WorkerMonitorMockgetRestingCountResults
	Counter uint64
}

// WorkerMonitorMockgetRestingCountResults contains results of the workerMonitor.getRestingCount
type WorkerMonitorMockgetRestingCountResults struct {
	u1 uint16
}

// Expect sets up expected params for workerMonitor.getRestingCount
func (mmgetRestingCount *mWorkerMonitorMockgetRestingCount) Expect() *mWorkerMonitorMockgetRestingCount {
	if mmgetRestingCount.mock.funcgetRestingCount != nil {
		mmgetRestingCount.mock.t.Fatalf("WorkerMonitorMock.getRestingCount mock is already set by Set")
	}

	if mmgetRestingCount.defaultExpectation == nil {
		mmgetRestingCount.defaultExpectation = &WorkerMonitorMockgetRestingCountExpectation{}
	}

	return mmgetRestingCount
}

// Inspect accepts an inspector function that has same arguments as the workerMonitor.getRestingCount
func (mmgetRestingCount *mWorkerMonitorMockgetRestingCount) Inspect(f func()) *mWorkerMonitorMockgetRestingCount {
	if mmgetRestingCount.mock.inspectFuncgetRestingCount != nil {
		mmgetRestingCount.mock.t.Fatalf("Inspect function is already set for WorkerMonitorMock.getRestingCount")
	}

	mmgetRestingCount.mock.inspectFuncgetRestingCount = f

	return mmgetRestingCount
}

// Return sets up results that will be returned by workerMonitor.getRestingCount
func (mmgetRestingCount *mWorkerMonitorMockgetRestingCount) Return(u1 uint16) *WorkerMonitorMock {
	if mmgetRestingCount.mock.funcgetRestingCount != nil {
		mmgetRestingCount.mock.t.Fatalf("WorkerMonitorMock.getRestingCount mock is already set by Set")
	}

	if mmgetRestingCount.defaultExpectation == nil {
		mmgetRestingCount.defaultExpectation = &WorkerMonitorMockgetRestingCountExpectation{mock: mmgetRestingCount.mock}
	}
	mmgetRestingCount.defaultExpectation.results = &WorkerMonitorMockgetRestingCountResults{u1}
	return mmgetRestingCount.mock
}

// Set uses given function f to mock the workerMonitor.getRestingCount method
func (mmgetRestingCount *mWorkerMonitorMockgetRestingCount) Set(f func() (u1 uint16)) *WorkerMonitorMock {
	if mmgetRestingCount.defaultExpectation != nil {
		mmgetRestingCount.mock.t.Fatalf("Default expectation is already set for the workerMonitor.getRestingCount method")
	}

	if len(mmgetRestingCount.expectations) > 0 {
		mmgetRestingCount.mock.t.Fatalf("Some expectations are already set for the workerMonitor.getRestingCount method")
	}

	mmgetRestingCount.mock.funcgetRestingCount = f
	return mmgetRestingCount.mock
}

// getRestingCount implements workerMonitor
func (mmgetRestingCount *WorkerMonitorMock) getRestingCount() (u1 uint16) {
	mm_atomic.AddUint64(&mmgetRestingCount.beforegetRestingCountCounter, 1)
	defer mm_atomic.AddUint64(&mmgetRestingCount.aftergetRestingCountCounter, 1)

	if mmgetRestingCount.inspectFuncgetRestingCount != nil {
		mmgetRestingCount.inspectFuncgetRestingCount()
	}

	if mmgetRestingCount.getRestingCountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmgetRestingCount.getRestingCountMock.defaultExpectation.Counter, 1)

		mm_results := mmgetRestingCount.getRestingCountMock.defaultExpectation.results
		if mm_results == nil {
			mmgetRestingCount.t.Fatal("No results are set for the WorkerMonitorMock.getRestingCount")
		}
		return (*mm_results).u1
	}
	if mmgetRestingCount.funcgetRestingCount != nil {
		return mmgetRestingCount.funcgetRestingCount()
	}
	mmgetRestingCount.t.Fatalf("Unexpected call to WorkerMonitorMock.getRestingCount.")
	return
}

// getRestingCountAfterCounter returns a count of finished WorkerMonitorMock.getRestingCount invocations
func (mmgetRestingCount *WorkerMonitorMock) getRestingCountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmgetRestingCount.aftergetRestingCountCounter)
}

// getRestingCountBeforeCounter returns a count of WorkerMonitorMock.getRestingCount invocations
func (mmgetRestingCount *WorkerMonitorMock) getRestingCountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmgetRestingCount.beforegetRestingCountCounter)
}

// MinimockgetRestingCountDone returns true if the count of the getRestingCount invocations corresponds
// the number of defined expectations
func (m *WorkerMonitorMock) MinimockgetRestingCountDone() bool {
	for _, e := range m.getRestingCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.getRestingCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.aftergetRestingCountCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcgetRestingCount != nil && mm_atomic.LoadUint64(&m.aftergetRestingCountCounter) < 1 {
		return false
	}
	return true
}

// MinimockgetRestingCountInspect logs each unmet expectation
func (m *WorkerMonitorMock) MinimockgetRestingCountInspect() {
	for _, e := range m.getRestingCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to WorkerMonitorMock.getRestingCount")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.getRestingCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.aftergetRestingCountCounter) < 1 {
		m.t.Error("Expected call to WorkerMonitorMock.getRestingCount")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcgetRestingCount != nil && mm_atomic.LoadUint64(&m.aftergetRestingCountCounter) < 1 {
		m.t.Error("Expected call to WorkerMonitorMock.getRestingCount")
	}
}

type mWorkerMonitorMockincreaseRestingCount struct {
	mock               *WorkerMonitorMock
	defaultExpectation *WorkerMonitorMockincreaseRestingCountExpectation
	expectations       []*WorkerMonitorMockincreaseRestingCountExpectation
}

// WorkerMonitorMockincreaseRestingCountExpectation specifies expectation struct of the workerMonitor.increaseRestingCount
type WorkerMonitorMockincreaseRestingCountExpectation struct {
	mock *WorkerMonitorMock

	Counter uint64
}

// Expect sets up expected params for workerMonitor.increaseRestingCount
func (mmincreaseRestingCount *mWorkerMonitorMockincreaseRestingCount) Expect() *mWorkerMonitorMockincreaseRestingCount {
	if mmincreaseRestingCount.mock.funcincreaseRestingCount != nil {
		mmincreaseRestingCount.mock.t.Fatalf("WorkerMonitorMock.increaseRestingCount mock is already set by Set")
	}

	if mmincreaseRestingCount.defaultExpectation == nil {
		mmincreaseRestingCount.defaultExpectation = &WorkerMonitorMockincreaseRestingCountExpectation{}
	}

	return mmincreaseRestingCount
}

// Inspect accepts an inspector function that has same arguments as the workerMonitor.increaseRestingCount
func (mmincreaseRestingCount *mWorkerMonitorMockincreaseRestingCount) Inspect(f func()) *mWorkerMonitorMockincreaseRestingCount {
	if mmincreaseRestingCount.mock.inspectFuncincreaseRestingCount != nil {
		mmincreaseRestingCount.mock.t.Fatalf("Inspect function is already set for WorkerMonitorMock.increaseRestingCount")
	}

	mmincreaseRestingCount.mock.inspectFuncincreaseRestingCount = f

	return mmincreaseRestingCount
}

// Return sets up results that will be returned by workerMonitor.increaseRestingCount
func (mmincreaseRestingCount *mWorkerMonitorMockincreaseRestingCount) Return() *WorkerMonitorMock {
	if mmincreaseRestingCount.mock.funcincreaseRestingCount != nil {
		mmincreaseRestingCount.mock.t.Fatalf("WorkerMonitorMock.increaseRestingCount mock is already set by Set")
	}

	if mmincreaseRestingCount.defaultExpectation == nil {
		mmincreaseRestingCount.defaultExpectation = &WorkerMonitorMockincreaseRestingCountExpectation{mock: mmincreaseRestingCount.mock}
	}

	return mmincreaseRestingCount.mock
}

// Set uses given function f to mock the workerMonitor.increaseRestingCount method
func (mmincreaseRestingCount *mWorkerMonitorMockincreaseRestingCount) Set(f func()) *WorkerMonitorMock {
	if mmincreaseRestingCount.defaultExpectation != nil {
		mmincreaseRestingCount.mock.t.Fatalf("Default expectation is already set for the workerMonitor.increaseRestingCount method")
	}

	if len(mmincreaseRestingCount.expectations) > 0 {
		mmincreaseRestingCount.mock.t.Fatalf("Some expectations are already set for the workerMonitor.increaseRestingCount method")
	}

	mmincreaseRestingCount.mock.funcincreaseRestingCount = f
	return mmincreaseRestingCount.mock
}

// increaseRestingCount implements workerMonitor
func (mmincreaseRestingCount *WorkerMonitorMock) increaseRestingCount() {
	mm_atomic.AddUint64(&mmincreaseRestingCount.beforeincreaseRestingCountCounter, 1)
	defer mm_atomic.AddUint64(&mmincreaseRestingCount.afterincreaseRestingCountCounter, 1)

	if mmincreaseRestingCount.inspectFuncincreaseRestingCount != nil {
		mmincreaseRestingCount.inspectFuncincreaseRestingCount()
	}

	if mmincreaseRestingCount.increaseRestingCountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmincreaseRestingCount.increaseRestingCountMock.defaultExpectation.Counter, 1)

		return

	}
	if mmincreaseRestingCount.funcincreaseRestingCount != nil {
		mmincreaseRestingCount.funcincreaseRestingCount()
		return
	}
	mmincreaseRestingCount.t.Fatalf("Unexpected call to WorkerMonitorMock.increaseRestingCount.")

}

// increaseRestingCountAfterCounter returns a count of finished WorkerMonitorMock.increaseRestingCount invocations
func (mmincreaseRestingCount *WorkerMonitorMock) increaseRestingCountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmincreaseRestingCount.afterincreaseRestingCountCounter)
}

// increaseRestingCountBeforeCounter returns a count of WorkerMonitorMock.increaseRestingCount invocations
func (mmincreaseRestingCount *WorkerMonitorMock) increaseRestingCountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmincreaseRestingCount.beforeincreaseRestingCountCounter)
}

// MinimockincreaseRestingCountDone returns true if the count of the increaseRestingCount invocations corresponds
// the number of defined expectations
func (m *WorkerMonitorMock) MinimockincreaseRestingCountDone() bool {
	for _, e := range m.increaseRestingCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.increaseRestingCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterincreaseRestingCountCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcincreaseRestingCount != nil && mm_atomic.LoadUint64(&m.afterincreaseRestingCountCounter) < 1 {
		return false
	}
	return true
}

// MinimockincreaseRestingCountInspect logs each unmet expectation
func (m *WorkerMonitorMock) MinimockincreaseRestingCountInspect() {
	for _, e := range m.increaseRestingCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to WorkerMonitorMock.increaseRestingCount")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.increaseRestingCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterincreaseRestingCountCounter) < 1 {
		m.t.Error("Expected call to WorkerMonitorMock.increaseRestingCount")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcincreaseRestingCount != nil && mm_atomic.LoadUint64(&m.afterincreaseRestingCountCounter) < 1 {
		m.t.Error("Expected call to WorkerMonitorMock.increaseRestingCount")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *WorkerMonitorMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockdecreaseRestingCountInspect()

		m.MinimockgetRestingCountInspect()

		m.MinimockincreaseRestingCountInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *WorkerMonitorMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *WorkerMonitorMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockdecreaseRestingCountDone() &&
		m.MinimockgetRestingCountDone() &&
		m.MinimockincreaseRestingCountDone()
}
